#X-Generator: crowdin.com
ardublock.file.suffix=Ardublock Programmdatei (*.abp)
ardublock.ui.new=Neu
ardublock.ui.save=Speichern
ardublock.ui.debug=Testausgaben
ardublock.ui.debug0=Debug: No
ardublock.ui.debug1=Debug: Normal
ardublock.ui.debug2=Debug: Detailliert


ardublock.ui.aiHelp=KI Unterstützung
ardublock.ui.saveAs=Speichern als
ardublock.ui.load=\u00d6ffnen
ardublock.ui.upload=Upload
ardublock.ui.generate=Generate File
ardublock.ui.clone=Klonen
ardublock.ui.add_comment=Kommentar hinzuf\u00fcgen
ardublock.ui.delete_comment=Kommentar l\u00f6schen
ardublock.ui.organize_blocks=Alle Bl\u00f6cke neu anordnen
ardublock.ui.create_refer=Verweis erstellen
ardublock.ui.website=Webseite
ardublock.ui.serialMonitor=Monitor
ardublock.ui.saveImage=Bild


ardublock.translator.exception.noLoopFound=Kein Programmrumpf gefunden\!
ardublock.translator.exception.multipleLoopFound=Mehrere Programmbl\u00f6cke gefunden\!
ardublock.translator.exception.subroutineNotDeclared=Das Unterprogramm ist nicht deklariert

message.title.error=Fehler
message.title.question=Frage
message.content.open_unsaved=Das Ardublock-Programm hat sich ge\u00e4ndert, m\u00f6chten Sie es vorher speichern?
message.content.overwrite=M\u00f6chten Sie die vorhandene Datei \u00fcberschreiben?
message.file_not_found=Datei wurde nicht gefunden oder der Zugriff wurde verweigert
#message.question.newfile_on_workspace_changed=Das aktuelle Programm hat sich ge\u00e4ndert, m\u00f6chten Sie trotzdem eine neue Ardublock-Datei erstellen?
message.question.newfile_on_workspace_changed=Das Programm hat sich ge\u00e4ndert, m\u00f6chten Sie es vorher speichern?

message.question.newboard=Das Board hat sich ge\u00e4ndert, m\u00f6chten Sie eine neue Ardublock-Datei erstellen?
message.question.exit=Das Programm hat sich ge\u00e4ndert, m\u00f6chten Sie das Fenster wirklich schließen?

ardublock.translator.exception.subroutineNameDuplicated=Zwei oder mehr Unterprogramme haben den selben Namen
ardublock.translator.exception.socketNull=Ein ben\u00f6tigter Wert oder eine Variable fehlt.\nHinweis:: Beachte den Anschlussteil (Schloss) im markierten Block

bg.Divider            =------------------------------
bg.Divider_I2C        =------  I2C        -----------
bg.Divider_Display    =------  Anzeigen   -----------
bg.Divider_Environment=------  Luft       -----------
bg.Divider_Distance   =------  Abstand    -----------
bg.Divider_Light      =------  Licht, Farbe ---------
bg.Divider_Sound      =------  Lärm, Audio  ---------

bg.Divider_Expand     =------  I/O, ADC   -----------
bg.Divider_GPS        =------  GPS        -----------
bg.Divider_LED        =------  LED        -----------
bg.Divider_Motor      =------  Motor      -----------
bg.Divider_Div        =------  Diverses   -----------
bg.Divider_NFC        =------  NFC / RFID -----------
bg.Divider_Bool       =------  Wahrheitswerte -------
bg.Divider_Num        =------  Zahlen     -----------
bg.Divider_String     =------  Text       -----------
bg.Divider_Predef     =------  Compiler Flags -------
bg.Divider_Time       =------  Aktuelle Zeit --------
bg.Divider_Array      =------  Datenfeld  -----------

bg.Divider_Math       =------  Mathematik -----------


bg.Divider_Loop       =------  Scheifen   -----------
bg.Divider_Case       =------  Fallunterscheidung  --
bg.Divider_UP         =------  Unterprogramm  -------
bg.Divider_Wait       =------  Timing, Warten  ------
bg.Divider_Code       =------  C-Code     -----------

bg.Divider_Test       =------  Vergleiche -----------
bg.Divider_Logic      =------  Logische Verknüpfung -
bg.Divider_Print      =------  Ausgabe ser. Monitor -
bg.Divider_Type       =------  Adapter (Typecast) ---
bg.Divider_Encoder    =------  Manuelle Eingabe  ----

bg.Divider_WiFi       =------  WLAN Client  ---------
bg.Divider_WiFiAP     =------  WLAN Hotspot ---------
bg.Divider_DNS        =------  DNS NameServer -------
bg.Divider_Server     =------  Eigener HTTP Server --
bg.Divider_Thing      =------  Thingspeak Cloud  ----
bg.Divider_Sense      =------  Umweltdaten Cloud ----
bg.Divider_Weight     =------  Gewicht, Kraft    ----
bg.Divider_Energy     =------  Energie Cloud     ----
bg.Divider_Smart      =------  Smart Home Cloud  ----
bg.Divider_Generic    =------  Universal Cloud   ----
bg.Divider_MQTT       =------  MQTT IoT-Cloud    ----
bg.Divider_LoRa       =------  LoRaWAN IoT-Cloud ----
bg.Divider_Blynk      =------  Blynk App-Cloud   ----
bg.Divider_SMTP       =------  E-mail SMTP        ----
bg.Divider_Messenger  =------  Messenger         ----

bg.Divider_Privacy    =------  Privatsphäre ---------
bg.Divider_Signal     =------  Signalverarbeitung ---

bg.Divider_ChatGPT    =------  Generative KI      ---
bg.Divider_KNN        =------  NN-Klassifikator   ---
bg.Divider_Reg        =------  Regressions Modell ---
bg.Divider_EDGE       =------  EDGE-KI Cloud      ---
bg.Divider_Audio      =------  Audio              ---
bg.Divider_BLE        =------  Bluetooth          ---
bg.Divider_INFLUX     =------  InfluxDB           ---
bg.Divider_Thingsboard=------  Thingsboard Cloud ----
bg.Divider_CO2        =------  CO2-Ampel    ---------
bg.Divider_Spektro    =------  Spektrometer ---------
bg.Divider_Balkon     =------  Balkonsolar  ---------
bg.Divider_IRQ        =------  Interrupt / Timer  ---
bg.Divider_ESP32      =------  System ESP32       ---
bg.Divider_ESP8266    =------  System ESP8266     ---
bg.Divider_RTC        =------  RTC / EEPROM       ---
bg.Divider_OTA        =------  OTA Update         ---
bg.Divider_RTOS       =------  FreeRTOS           ---


bg.program= 
bg.program.description=Rumpf f\u00fcr das Hauptprogramm beim Arduino. Setup wird einmalig ausgef\u00fchrt, anschließend folgt die Endlosschleife.
bc.setup=Setup 
bg.setup=setup 
bc.loop=Schleife 
bg.loop=Wiederhole fortlaufend 
bg.loop.description=Schleife mit automatischem Setup 
bg.repeat_times=Wiederhole 
bg.repeat_times.description=Wiederhole die Befehle genau eine bestimmter Anzahl mal. Der aktuelle Z\u00e4hlerstand ist in der Schleife in der Variable count verf\u00fcgbar.  
bc.repeat_times=Mal 
bc.commands=Befehle 
bg.repeat=Zählschleife 
bg.repeat.description=Wiederhole die Befehle genau eine bestimmter Anzahl mal.
bg.repeat2.description=Wiederhole die Befehle genau eine bestimmter Anzahl mal. Der aktuelle Z\u00e4hlerstand ist in der Schleife in der Variable count verf\u00fcgbar.  
bg.repeat2=Zählschleife 
bc.from=Von
bc.to=Bis

bc.variable=Variable 
bg.variable_poly=Name der String-Variable (Text) 
bg.variable_number_LoRaPayload=LoRaWAN_Rx_Payload 
bg.variable_number_LoRaPayload.description=Lesezugriff auf den Payload des Kommunikationsprotokolls (als Ganze Zahl) 
bg.while=Solange 
bg.while.description=Solange der Test der Bedingung ein wahr liefert, werden die Befehle wiederholt 
bc.condition=Teste 
bg.if=Falls 
bg.ifelse=Falls/sonst 
bg.if.description=Führe die Befehle nur aus, falls der Test der Bedingung ein wahr ergibt 
bg.ifelse.description=Führe die Befehle im ersten Block nur aus, falls der Test der Bedingung ein wahr ergibt. Sonst führe den zweiten Block aus 
bc.test=teste 
bc.then=dann 
bg.ifelse=Falls/sonst 
bg.ifelse.description=Führe die Befehle im ersten Block nur aus, falls der "test" der Bedingung ein wahr ergibt. Sonst führe den zweiten Block aus 
bc.else=sonst 
bg.switchcase=case 
bg.switchcase.description=Switch and select the case 

bg.delay.description=Warte eine Anzahl "Millisekunden".\nNOTE: 1000 Millisekunden = 1 Sekunde 
bg.delay=Delay (warte) 
#bg.delay_microseconds=Warte ein paar Mikrosekunden 
bc.milliseconds=ms 
bg.subroutine=Unterprogramm 
bg.subroutine-ref=Unterprogramm 
bg.subroutine.description=Erstellt ein neues Unterprogramm (Definition) 
bg.subroutine-ref.description=Unterprogramm aufrufen 
bg.sub_return=UnterprogrammReturn 
bg.sub_return.description=Unterprogramm mit Returnparameter  
bg.sub_return-ref=UnterprogrammReturn 
bg.sub_return-ref.description=Aufruf Unterprogramm mit Returnparameter 
bc.sub_return = Rückgabewert 
bc.sub_commands = Unterprogramm Befehle 
bg.code = C
bg.codeg = C (global aera)
bg.code.description = C
bg.codeg.description = C (global aera)


bg.greater=> 
bg.greater.description=Wahr, wenn die erste Zahl gr\u00f6\u00dfer ist als die zweite Zahl 
bg.less=< 
bg.less.description=Wahr, wenn die erste Zahl kleiner ist als die zweite Zahl 
bg.equal.description=Wahr, wenn die erste Zahl gleich gro\u00df ist wie die zweite Zahl 
bg.equal_digital.description=Wahr, wenn die erste Zahl gleich gro\u00df ist wie die zweite Zahl 
bg.equal_poly.description=Wahr, wenn das erstes Zeichen identisch mit dem zweiten Zeichen 
bg.equal_poly= == 
bg.equal_digital=== 
bg.equal=== 
bg.equal_digital.description=True if the first number equals to the second number 
bg.equal_poly.description=True if first character is equal to the second character 


bg.greater_equal=>\= 
bg.greater_equal.description=Wahr, wenn die erste Zahl gr\u00f6\u00dfer als oder gleich gro\u00df ist wie die zweite Zahl 
bg.less_equal=<\= 
bg.less_equal.description=Wahr, wenn die erste Zahl kleiner als oder gleich gro\u00df ist wie die zweite Zahl 
bg.not_equal_digital=\!\= 
bg.not_equal_digital.description=Wahr, wenn die erste Zahl nicht gleich gro\u00df ist wie die zweite Zahl 
bg.and=und 
bg.and.description=Wahr, wenn beide beide Bedingungen erf\u00fcllt sind. 
bg.or=oder 
bg.or.description=Wahr, wenn eine oder beide beide Bedingungen erf\u00fcllt sind. 
bg.not_equal_poly=\!\= 
bg.not_equal_digital=\!\= 
bg.not=nicht 
bg.not_equal=\!\= 
bg.not_equal.description=Wahr, wenn die erste Zahl nicht gleich gro\u00df ist wie die zweite Zahl 
bg.not_equal_digital.description=Wahr, wenn die erste Zahl nicht gleich gro\u00df ist wie die zweite Zahl 
bg.not.description=Das Gegenteil von 
bg.not_equal_poly.description=Wahr, wenn das erstes Zeichen nicht identisch mit dem zweiten Zeichen 
bg.equal_string= == 
bg.equal_string.description=Wahr, wenn die beiden Texte identisch gleich sind 
bg.not_equal_string= != 
bg.not_equal_string.description=Wahr, wenn die beiden Texte nicht identisch sind 


bg.isnan=isnan 
bg.isnan.description=True if the number is NaN 
bg.isempty=isempty 
bg.isempty.description=True if string is empty 
bg.addition=+ 
bg.addition.description=Summe zweier Zahlen 
bg.subtraction=- 
bg.subtraction.description=Differenz zweier Zahlen 
bg.multiplication=x 
bg.multiplication.description=Produkt zweier Zahlen 
bg.division=\u00f7 
bg.division.description=Quotient zweier Zahlen 
bg.modulo=% 
bg.modulo.description=Der Ganzzahlrest ist der Rest der Division (ähnlich Modulo)
bg.abs=Betrag 
bg.abs.description=Betrag  
bg.round=Rundung 
bg.round.description=Rundung 
bc.decimals=Stellen
bc.decimals.description=Anzahl der Nachkommastellen
bg.pow=Potenz 
bg.pow.description=Potenzfunktion 

bc.base=Basis 
bc.base.description=Basis der Potenzfunktion

bc.exponent=Exponent
bc.exponent.description=Exponent der Potenzfunktion
 
bg.sqrt=Wurzel 
bg.sqrt.description=Quadratwurzel 

bg.sin=sin 
bg.sin.description=Sinusfunktion (rad) 
bg.cos=cos 
bg.cos.description=Cosinusfunktion (rad) 
bg.tan=tan 
bg.tan.description=Tangenzfunktion
bg.random=Zufallszahl 
bg.random.description=Generiert eine zuf\u00e4llige Zahl, die kleiner ist als die Zahl 
bc.max=max 
bg.max=Max 
bg.max.description=Maximum 
bg.millis=millis 
bg.millis.description=Zählt die Millisekunden seit Einschalten 
bg.number=1 
bg.number.description=Eine konstante Zahl 
bg.digital-high=HIGH (wahr) 
bg.digital-high.description=Binäre Konstante wahr, High-Potential 
bg.digital-low=LOW (falsch) 
bg.digital-low.description=Binäre Konstante falsch, Low-Potential 
bg.true=true 
bg.true.description=Binäre Konstante wahr / HIGH 
bg.false=false 
bg.false.description=Binäre Konstante falsch / LOW
bg.variable_number=Name Integer Variable
bg.variable_number.description=Zugriff auf Zahl-Variable (Integer, ganze Zahl)
bg.variable_number_double=Name Float Variable 
bg.variable_number_double.description=Zugriff auf Gleitkommazahl (Float)
bg.variable_digital=Name Boolean Variable  
bg.variable_digital.description=Zugriff auf binäre Variable (Boolean) mit den zwei Zuständen "wahr" und "falsch". 
bg.setter_predef_number=PREDEFINITION
bg.setter_predef_number.description=Erstellt eine Compiler Predefinition. Blöckchen sollte am Beginn des setup() stehen. #define PREDEFINITION value
bg.predef_number.description=Nutze eine per #define erklärte Compiler-Konstante
bg.predef_number=PREDEFINITION 

bg.setter_variable_number=Setze Zahl-Variable  
bg.setter_variable_number.description=Wertzuweisung einer Zahl-Variable 
bg.setter_variable_number_double=Setze Zahl-Variable (Float) 
bg.setter_variable_number_double.description=Wertzuweisung einer Zahl-Variable (Gleitpunktzahlen) 
bc.value=Wert 

bg.local_variable_number= Lokale Integer Variable 
bg.local_variable_number.description =Zugriff auf lokale Zahl-Variable (nur ganze Zahlen) 
bg.variable_number_LoRaPayload=LoRaWAN_Rx_Payload
bg.variable_number_LoRaPayload.description=read LoRaWAN RX payload (int)
bg.variable_number_LoRaPort=LoRaWAN_Rx_Port
bg.variable_number_LoRaPort.description=read LoRaWAN RX port (int8)
bg.variable_String_LoRaPayload=LoRaWAN_Rx_Payload_Raw
bg.variable_String_LoRaPayload.description=read LoRaWAN RX String
bg.readArrayVarNum=Lese Array 
bg.readArrayVarNum.description=Lese einen Wert vom Datenfeld am angegebenen Index, dieses Array wird im OLED und der Charlieplex-Matrix angezeigt 
bg.setArrayVarNum=Schreibe Array 
bg.setArrayVarNum.description=Setze Wert im Datenfeld an der angegebenen Stelle, dieses Array wird im OLED und der Charlieplex-Matrix dargestellt

bg.readArray2VarNum=Lese Array 2 
bg.readArray2VarNum.description=Lese einen Wert vom zweiten Datenfeld am angegebenen Index 
bg.setArray2VarNum=Schreibe Array 2 
bg.setArray2VarNum.description=Setze Wert im zweiten Datenfeld an der angegebenen Stelle



bg.matrixArrayDisplay=LED-Matrix Array 
bg.matrixArrayDisplay.description=Visualisierung eines Arrays auf der LED-Matrix
 
bg.setter_variable_digital=Setze Binär-Variable 
bg.setter_variable_digital.description=Wertzuweisung einer binären Variable 
bg.setter_variable_String=Setze Text-Variable 
bg.setter_variable_String.description=Wertzuweisung einer String-Variable (Text) 
bg.variable_String=Name der String-Variable 
bg.variable_String.description=Lesezugriff auf String-Variable. Dies ist der Variablenname, kein auszugebender Text 
bg.variable_String_Payload=Rx_Payload 
bg.variable_String_Payload.description=Lesezugriff auf letzten Payload (String). Dieser enthält die unter dem Topic übertragene Information 
bg.serial_print=Serial print 
bg.serial_print.description=Sendet eine Nachricht \u00fcber die serielle Schnittstelle
bg.serial_debug=Debug print 
bg.serial_debug.description=Sendet eine Debug-Nachricht \u00fcber die serielle Schnittstelle 
 
bg.serial_readString=Serial read 
bg.serial_readString.description=Liest eine Nachricht von der seriellen Schnittstelle 
bg.serial_print_num=serial print 
bg.serial_print_num.description=print message serial monitor
bg.serial_available=serial available 
bg.serial_available.description=serial available 


bc.message=Message 
bg.message=Hallo Welt
bg.message.description=Ein konstanter Text (z.B. "Hallo Welt")
bc.ln=neue Zeile 
bg.glue_sn=verbinde 
bg.glue_sn.description=Adapter (typcast), wandelt Zahl zu einer Zeichenkette 
bg.glue_sb=verbinde 
bg.glue_sb.description=Adapter (typcast), wandelt binäre Werte zu einer Zeichenkette 
bg.glue_poly=verbinden 
bg.glue_poly.description=Adapter (typcast), wandelt Zeichen zu einer Zeichenkette
bg.cat_string=verbinde
bg.cat_string.description=Verbindet zwei Zeichenketten 
bg.cat_string3=verbinde
bg.cat_string3.description=Verbindet drei Zeichenketten 

bg.glue_nb=verbinde 
bg.glue_nb.description=Adapter (typecast), wandelt binäre Werte zu einer Zahl
bg.glue_ns=verbinde 
bg.glue_ns.description=Adapter (typecast), wandelt Zeichenkette zu einer Zahl 


bg.pin-mode-pullup=Pullup Widerstand für digitalRead 
bg.pin-mode-pullup.description=Schaltet ggf. einen internen Pullup-Widerstand  
bg.pin-read-digital=digitalRead (digitaler Eingang) 
bg.pin-read-digital.description=Liest den Digitalwert von einem GPIO-Pin 
bg.button_press =Encoder (button) 
bg.button_press.description =Einlesen des Encoder-Knopfes (drücken des Knopfes) 
bg.button_rot   =Encoder (turn) 
bg.button_rot.description   =Einlesen der Drehbewegung des Encoder-Knopfes (drehen)
bg.button_rot_minmax=Encoder (bounds) 
bg.button_rot_minmax.description=Begrenzt den Wertebereich des Drehencoders

bg.button_rot_minmax2=Encoder (bounds) 
bg.button_rot_minmax2.description=Begrenzt den Wertebereich des Drehencoders und gibt Startwert vor
 
bg.touch_rot   =Touch (turn) 
bg.touch_rot.description   =read touch (turn) 
bg.touch_press   =Touch (button) 
bg.touch_press.description   =read touch button 
bg.touch_rot_minmax=Touch (bounds) 
bg.touch_rot_minmax.description=upper and lower limits 



bg.pin-read-analog=analogRead (analoger Eingang)
bg.pin-read-analog.description=Lies den Analogwert vom angegebenen pin 
bg.GetBMETemp=Temperatur 
bg.GetBMETemp.description=Messwert für Temperatur 
bg.GetBMEPress=Druck
bg.GetBMEPress.description=Messwert für Luftdruck vom Bosch-Sensor
bg.GetBMEHum=Luftfeuchte
bg.GetBMEHum.description=Messwert Luftfeuchte vom Bosch-Sensor

bg.GetBME=Umwelt BME280 
bg.GetBME.description=Umweltinformation vom Bosch BME 280
bg.GetBME_Adr=Umwelt (T,F,p) BME280
bg.GetBME_Adr.description=Umweltinformation vom Bosch BME 280. Der Baustein funktioniert auch für den BMP280 (ohne Feuchte). Typische I2C-Adressen sind 0x76 oder 0x77
bc.BMEVector=Sensor 
bg.BMEVectorPress=Luftdruck 
bg.BMEVectorTemp=Temperatur 
bg.BMEVectorHum=Luftfeuchte 

bg.GetBME680=Temp, Feuchte, Druck, VOC BME680
bg.GetBME680.description=Umweltinformation vom Bosch BME 680. Arbeitet direkt, d.h. ohne BSEC-Algotithmus. <offset> korrigiert den Messwert manuell, indem der offset zum Messwert dazu addiert wird. <gasheat> bestimmt die Heiztemperatur bei der Gasmessung (in Grad C) 
bg.GetBME680offset=Umwelt (T,F,p,VOC) BME680
bg.GetBME680offset.description=Umweltinformation vom Bosch BME 680. Arbeitet direkt, d.h. ohne BSEC-Algorithmus
bg.BME680VectorPress=Luftdruck 
bg.BME680VectorTemp=Temperatur 
bg.BME680VectorHum=Luftfeuchte 
bg.BME680VectorGas=Gassensor 
bg.BME680VectorIAQ=IAQ 

bg.GetBSEC=Umwelt (T,F,p,VOC) BSEC2 
bg.GetBSEC.description=Umweltinformation vom Bosch BME 680, intelligente Korrektur durch BSEC-Algorithmus  
bg.BSECVectorIAQ=IAQ
bg.BSECVectorIAQAccuracy=IAQ Accuracy
bg.BSECVectorTemp=Temperatur
bg.BSECVectorHum=Feuchte (corr.)
bg.BSECVectorPress=Luftdruck
bg.BSECVectorCO2=CO2 (equivalent)
bg.BSECVectorVOC=VOC (breath)
bg.BSECVectorHumRaw=Feuchte (raw)
bg.BSECVectorTempRaw=Temp (raw)
bg.BSECVectorGasRaw=Gas

bg.ToffsetSCD30=SCD30 Temperature offset
bg.ToffsetSCD30.description=Set Temperature offset 

bg.CalSCD40=Calibrate SCD4x to fresh air
bg.CalSCD40.description=Set calibration parameter



bg.DosisIntegral=Integral
bg.DosisIntegral.description=Berechnet das Integral einer Messgröße 
bg.EMAsmooth=Exponentielle Glättung
bg.EMAsmooth.description=Glättet das Signal mittels exponentiellem Mittelwert (exponential moving average). Zeitkonstante legt die Dynamik fest 

bg.MEANsmooth=Mittelwert
bg.MEANsmooth.description=Führt mehrere Abtastungen durch und mittelt diese. Wartezeit zwischen den Abtastungen entsprechend der Sensordynamik. 

bg.GetSCD40=CO2 Sensirion SCD4x 
bg.GetSCD40.description=Umweltinformation vom Sensirion SCD40
bg.CalSCD40=CO2 Kalibriere SCD4x
bg.CalSCD40.description=Kalibriert den Sensor auf Frischluft = 400 ppm. Dazu ist vorher längere Zeit unter Frischluftbedingungen nötig
bg.GetSCD30=CO2 Sensirion SCD30
bg.CalSCD30=CO2 Kalibriere SCD30 
bg.CalSCD30.description=Kalibriert den Sensor auf Frischluft = 400 ppm. Dazu ist vorher längere Zeit unter Frischluftbedingungen nötig
bg.GetSCD30.description=Umweltinformation vom Sensirion SCD30
bc.SCD30Vector=Sensor 
bg.SCD30VectorCO2=CO2 
bg.SCD30VectorTemp=Temperatur 
bg.SCD30VectorHum=Luftfeuchte 

bg.GetK30=CO2 K30 
bg.GetK30.description=CO2 Sensor K30 

bg.NTC_Temp=NTC-Widerstand
bg.NTC_Temp.description= NTC-Heißleiter, Beta-Formel für Temperatur in Grad Celsius, s. https://www.elektronik-kompendium.de/sites/formeln/heissleiter-ntc

bg.GetMHZ19=CO2 MH-Z19 
bg.GetMHZ19.description=Environmental Information from MH-Z19
bc.MHZ19Vector=sensor 
bg.MHZ19VectorCO2=CO2 
bg.MHZ19VectorTemp=temperature 
bg.CalMHZ19=CO2 Calibrate MH-Z19 to fresh air
bg.CalMHZ19.description=Set calibration parameter


bg.GetGPSI2C=GPS I2C PA1010
bg.GetGPSI2C.description=GPS Coordinates I2C GPS Modul 
bg.GetGPS.description=GPS coordinates



bg.GetGPS=GPS Serial MTK3339
bg.GetGPS.description=Ermittle GPS Koordinaten. Updatefix holt neue Datensatz vom Sensor, die anderen Parameter lesen den Datensatz. Nur dann sind die Daten konsistent.
bc.GPSVector=Data 
bg.GPSVectorUpdate=SatUpdateFix 
bg.GPSVectorLat=Breitengrad 
bg.GPSVectorLong=Laengengrad
bg.GPSVectorAlt=Hoehe
bg.GPSVectorHdop=Hdop

bg.GetBNO=Lage Bosch BNO  
bg.GetBNO.description=Liefert die Orientierung im Raum 
bc.BNOVector=Sensor 
bc.BNOVector.description=Sensortyp 
bg.BNOVectorAcc=Beschleunigung 
bg.BNOVectorOrient=Orientierung 
bg.BNOVectorGyro=Gyroscope 
bg.BNOVectorMagnet=Magnetfeld 
bc.BNODim=Achse 
bc.BNODim.description=Achseninformation 
bg.BNODimX=X-Achse 
bg.BNODimY=Y-Achse 
bg.BNODimZ=Z-Achse 


bg.LCDGroveRGB = Grove LCD
bg.LCDGroveRGB.description = LCD Display
bg.OLED_DispArray =OLED Plot Zeitreihe
bg.OLED_DispArray.description = Zeitreihe auf dem OLED-Display zeichnen. Der Wert <value> definiert den Messwert, <min> und <max> sorgen für die Achsenskalierung. (Quelle für Hardware: https://www.adafruit.com/product/4650)
bg.OLED_ClearArray =OLED Clear Zeitreihe
bg.OLED_ClearArray.description = Die aktuell auf dem OLED-Display dargestellte Zeitreihe löschen.

bg.OLED_AddArray =OLED Add Value Zeitreihe
bg.OLED_AddArray.description = Einen Messwert zur aktuellen OLED-Zeitreihe hinzufügen.


bg.OLED = OLED
bg.OLED.description = OLED
bg.OLED_Print = OLED Print Canvas
bg.OLED_Print.description = print text to OLED canvas

bg.OLED_Print3 = OLED Print
bg.OLED_Print3.description = print text to OLED 

bg.OLED_Clear = OLED Clear Canvas
bg.OLED_Clear.description = clear OLED canvas

bg.OLED_ClearDisplay = OLED Clear Display
bg.OLED_ClearDisplay.description = clear OLED display


bg.OLED_Font = OLED Font Canvas
bg.OLED_Font.description = set OLED font

bg.OLED_FontMono =Mono
bg.OLED_FontSans =Sans

bg.OLED_FontTypeBold =Bold
bg.OLED_FontTypeOblique =Oblique
bg.OLED_FontTypePlain =Plain

bg.OLED_FontSize7  =7pt
bg.OLED_FontSize9  =9pt
bg.OLED_FontSize12 =12pt
bg.OLED_FontSize18 =18pt
bg.OLED_FontSize24 =24pt




bg.OLED_Display = OLED Display Canvas
bg.OLED_Display.description = display canvas

bg.OLED_PrintTerminal = OLED print
bg.OLED_PrintTerminal.description = display text on OLED
   
bg.Feather7Seg =7-Segment-Display
bg.Feather7Seg.description = Ausgabe auf 7-Segment-Display (https://learn.adafruit.com/adafruit-7-segment-led-featherwings/overview)
bc.7Seg=Ausgabe
bc.7Seg.description=Ausgabe 7-Segment-Anzeige

bg.ADPS9960Get=Farbe, Geste, Abstand APDS9960 
bg.ADPS9960Get.description=Farb-, Abstands- und Gestenerkennung 
bg.ADPS9960Cal=Farbe Weissabgleich APDS9960 
bg.ADPS9960Cal.description=Kalibiere die Farberkennung (weißes Papier vor den Sensor halten) 
bc.ADPS9960Vector=Sensor 
bc.ADPS9960Vector.description=Sensortyp 
bg.ADPS9960Gest=Gesten 
bg.ADPS9960Prox=Abstand (raw)
bg.ADPS9960Ambi=Licht (Lux)
bg.ADPS9960Red=Rot 
bg.ADPS9960Green=Gruen 
bg.ADPS9960Blue=Blau 


bg.ADPS9999Get=Farbe, Abstand, Licht APDS9999 
bg.ADPS9999Get.description=Farb-, Licht- und Abstandserkennung 
bg.ADPS9999Cal=Farbe Weissabgleich APDS9999 
bg.ADPS9999Cal.description=Kalibiere die Farberkennung (weißes Papier vor den Sensor halten) 
bc.ADPS9999Vector=Sensor 
bc.ADPS9999Vector.description=Sensortyp 
bg.ADPS9999Prox=Abstand (raw) 
bg.ADPS9999Dist=Abstand (cm) 
bg.ADPS9999Ambi=Licht (Lux)
bg.ADPS9999Red=Rot 
bg.ADPS9999Green=Gruen 
bg.ADPS9999Blue=Blau 
bg.ADPS9999IR=IR 





bg.TCS34725Get=Farbe TCS34725 
bg.TCS34725Get.description=RGB Color
bc.TCS34725Vector=Sensor 
bc.TCS34725Vector.description=Sensortype 
bg.TCS34725Red=Red 
bg.TCS34725Green=Green 
bg.TCS34725Blue=Blue
bg.TCS34725Lux=Lux 

bg.INA219Get=Current, Voltage INA219
bg.INA219Get.description=Current and load sensor
bc.INA219Vector=Sensor 
bc.INA219Vector.description=Current Sensor 
bg.INA219Current=Current [mA]
bg.INA219LoadVoltage=LoadVoltage [V] 
bg.INA219Power=Power [mW]

bg.NFCRead=NFC-Reader 
bg.NFCRead.description=Lese NFC-Tags (Mifare)
bc.NFCVector=Type 
bc.NFCVector.description=Informationstyp
bg.NFCVectorHash=Hash ID 
bg.NFCVectorID=ID 
bg.NFCVectorPay=Payload
bg.NFCVectorHash.description=Hash ID 
bg.NFCVectorID.description=ID 
bg.NFCVectorPay.description=Payload

bg.NFCWrite=NFC-Write 
bg.NFCWrite.description=Schreibe NFC-Payload auf das Tag (Mifare)
bc.NFCmessage=Payload 
bc.NFCmessage.description=Payload Text 
bg.NFCmessage=Payload
bg.NFCmessage.description=Payload Text 

bg.GetMGas=Multigas Sensor MiCS-6814 
bg.GetMGas.description=Multisensor Gasmessung in ppm
bc.MGasVector=sensor 
bc.MGasVector.description=gas sensor (ppm) 
bg.MGasVectNH3=NH3 (ppm)
bg.MGasVectCO=CO (ppm)
bg.MGasVectNO2=NO2 (ppm)
bg.MGasVectC3H8=C3H8 (ppm) 
bg.MGasVectC4H10=C4H10 (ppm)
bg.MGasVectCH4=CH4 (ppm)
bg.MGasVectH2=H2 (ppm)
bg.MGasVectC2H5OH=C2H5OH (ppm)
bg.MGasVectRawR00=Kanal0 R0
bg.MGasVectRawRS0=Kanal0 Rs
bg.MGasVectRawR01=Kanal1 R0
bg.MGasVectRawRS1=Kanal1 Rs
bg.MGasVectRawR02=Kanal2 R0
bg.MGasVectRawRS2=Kanal2 Rs

bg.GetMaxbotix=Abstand Maxbotix Ultraschall
bg.GetMaxbotix.description=Ultrasonic Distance

bg.GetMaxbotix2=Abstand Maxbotix Ultraschall
bg.GetMaxbotix2.description=Abstandsmessung mit Maxbotix Sensoren (Ultrasonic Distance)

bg.GetMaxbotix3=Abstand Maxbotix Ultraschall
bg.GetMaxbotix3.description=Abstandsmessung mit Maxbotix Sensoren (Ultrasonic Distance)

bg.MAX7368=7368 (10 m)
bg.MAX7368.description= Messbereich 300 bis 9999 mm
bg.MAX7369=7369 (5 m)
bg.MAX7369.description= Messbereich 300 bis 5000 mm


bg.UART_SW =SW Serial
bg.UART_SW.description=Software Serial 

bg.UART_1=HW UART 1
bg.UART_1.description=Hardware Serial UART 1

bg.UART_2=HW UART 2
bg.UART_2.description=Hardware Serial UART 2

bg.MapC=Mapping 
bg.MapC.description=Ermöglicht die Umrechnung von Werten auf einen anderen Bereich. Es wird von <in> auf <out> gemapped. Nur Interpolation, keine Extrapolation, Werte werden begrenzt  


bg.medianfilter=Medianfilter 
bg.medianfilter.description=Medianwerte ermitteln, macht die Messung robust gegen Ausreisser. Führt drei Messungen des an <value> angeschlossenen Sensors durch. Zwischen den Messungen gibt es ggf. eine mit <pause> zu definierende Wartezeit (z.B. lightsleep). Falls die erfassten Messwerte außerhalb des durch <valueMin> und <valueMax> begrenzten Bereichs liegen, wird die Messung mehrfach wiederholt. Anschließend werden die Messungen sortiert und der mittlere Wert (Median ist nicht der Mittelwert) zurückgeliefert. 
bg.GetDFRobotUS=Abstand DFRobot Ultraschall
bg.GetDFRobotUS.description=Ultrasonic Distance (https://wiki.dfrobot.com/A01NYUB%20Waterproof%20Ultrasonic%20Sensor%20SKU_SEN0313#target_7)

bg.GetDustHM330=Feinstaub HM330
bg.GetDustHM330.description=Feinstaubsensor HM330
bg.GetDustHoney=Feinstaub Honeywell
bg.GetDustHoney.description=Feinstaubsensor Honeywell
bc.DustHoneyVector=Groesse
bc.DustHoneyVector.description=Partikelgroesse
bg.DustHoneyVect25 = PM 2.5 (µg/m3)
bg.DustHoneyVect10 = PM 10  (µg/m3)
bg.DustHoneyVect1  = PM 1.0 (µg/m3)






bg.GetLightBH=Licht BH1750
bg.GetLightBH.description=Lichtsensor BH1750
bg.GetLightTSL=Lightsensor TSL2561
bg.GetLightTSL.description=Lightsensor TSL2561
bg.GetLightTSLnew=Lightsensor TSL2561
bg.GetLightTSLnew.description=Lightsensor TSL2561

#bc.LightTSLVector=Spektrum
#bc.LightTSLVector.description=Lichtspektrum Detektor
bg.LightTSLVectLux =Beleuchtung (lux)
bg.LightTSLVectVis =Breitband (vis+ir)
bg.LightTSLVectIR = Infrarot (ir)

bg.GetHX711=Waage HX711, Messwert
bg.GetHX711.description=Messwert in Units, vorher kalibrieren

bg.DS18B20Get=Temp DS18B20 Get
bg.DS18B20Get.description = One-Wire Sensor, see https://mischianti.org/dallas-ds18b20-with-esp32-and-esp8266-all-onewire-topologies-long-stubs-and-more-devices/
bg.DS18B20Get32=Temp DS18B20 Get 
bg.DS18B20Get32.description = One-Wire, neuen Messwert holen. Vorher einen Request initiieren, nur für ESP32, deepsleep fest
bg.DS18B20Req32=Temp DS18B20 Req 
bg.DS18B20Req32.description = One-Wire, request neuen Messwert (je nach Auflösung in 100 bis 800 ms verfügbar), nur für ESP32, deepsleep fest

bg.DS18B20_get_req=get and request
bg.DS18B20_get_req.description=Letzten Messwert holen und eine neue Messung anfordern. Der Messwert ist damit einen Abtastzyklus alt.
bg.DS18B20_req_get=request, wait and get
bg.DS18B20_req_get.description=Neue Messung anfordern und den aktuellen Messwert zurückliefern. Warte auf neusten Messwert.  
bg.DS18B20_req=request
bg.DS18B20_req.description=Neue Messung anfordern
bg.DS18B20_get=get 
bg.DS18B20_get.description=Letzten Messwert holen (muss vorher angefordert werden)


bg.TaraHX711=Waage HX711, Tara
bg.TaraHX711.description=Setzt Tara, bestimmt den Offset
bg.CalHX711=Waage HX711, Kalibrieren
bg.CalHX711.description=Kalibriert in Units (z.B. kg, g oder Stück). Liefert die Kalibriersteigung. Diese kann später per Blöckchen gesetzt werden und vermeidet so das Kalibrieren bei jedem Neustart

bg.GetScaleHX711=Waage HX711, Kalibriersteigung lesen
bg.GetScaleHX711.description=Kalibriersteigung nach erfolgter Kalibrierung auslesen
bg.SetScaleHX711=Waage HX711, Kalibriersteigung setzen
bg.SetScaleHX711.description=Kalibriersteigung setzen, ersetzt Neukalibrierung bei jedem Neustart



bg.askSMARD=SMARD Stromdaten
bg.askSMARD.description= Dieser Block liefert eine Schätzung für den Anteil erneuerbarer Energieen ind Deutschland. Grundlage ist die SMARD Datenbank der Bundesnetzagentur. Die Daten werden zyklisch abgefragt, der Anteil berechnet und online bereitgestellt. Studienarbeit am Umwelt-Campus (https://www.umwelt-campus.de/iot-werkstatt/tutorials/klimaschutz-iot-stromboerse-und-co2)
bg.SMARDVectRen=Anteil EE [%]
#bg.SMARDVectCO2=CO2 / kWh




bg.DIYSpectro=Spektrometer TSL2561
bg.DIYSpectro.description=Absorptionsspektrometer mit TSL2561, gemeinsam mit HAW Hamburg (https://www.haw-hamburg.de/hochschule/life-sciences/forschung/projekte-schullabor/schullabor-mobile-analytik/) 
bg.DIYSpectroBH=Spektrometer BH1750
bg.DIYSpectroBH.description=Absorptionsspektrometer mit BH1750, gemeinsam mit HAW Hamburg (https://www.haw-hamburg.de/hochschule/life-sciences/forschung/projekte-schullabor/schullabor-mobile-analytik/) 
bg.DIYSpectroVectOctiW  =Neopixel Weiss 
bg.DIYSpectroVectOctiRGB=Neopixel RGB   
bg.DIYSpectroVectD1W    =Mono GPIO 15

bg.absHum=Abs. Feuchte
bg.absHum.description=Berechnet die absolute Luftfeuchte. Grundlage: Temperatur und aktuelle relative Feuchte

bg.initHM=init Hoymiles
bg.initHM.description=init Hoymiles
bg.getHM=read Hoymiles
bg.getHM.description=read Hoymiles
#bg.HMVect300=HM300, TSUN350
#bg.HMVect300.description=300
#bg.HMVect400=HM400
#bg.HMVect400.description=400
#bg.HMVect600=HM600
#bg.HMVect600.description=600
#bg.HMVect800=HM800
#bg.HMVect800.description=800
#bg.HMVect1200=HM1200
#bg.HMVect1200.description=1200
#bg.HMVect1600=HM1600
#bg.HMVect1600.description=1200


bg.SX1509_read = Port Expander SX1509 
bg.SX1509_read.description = Erweitert den I/O-Bereich um digitale Eingänge
bg.pin-read-digital_SX = SX1509 Digital Input
bg.pin-read-digital_SX.description=Der SX1509 erweitert den IO-Bereich um digitale Eingänge
bg.SX1509_write = Port Expander SX1509
bg.SX1509_write.description = Erweitert den I/O-Bereich um digitale Ausgänge
bg.pin-write-digital_SX = SX1509 Digital Output
bg.pin-write-digital_SX.description = Port Expander Digital Output

bg.SD_print = SD-Card
bg.SD_print.description = SD-Card


bg.MPR121_read = Touch Sensor MPR121
bg.MPR121_read.description = Der MPR121 erweitert den I/O-Bereich um einen Touch Sensor
bg.pin-read-digital_MP = Touch Sensor
bg.pin-read-digital_MP.description = Touch Sensor Input

bg.feather_motor = Feather DC-motor 
bg.feather_motor.description = Anteuerung eines Gleichstrommotors mit dem Feather Motor Shield (Geschwindigkeit positiv und negativ)

bg.feather_stepmotor = Feather Stepper 
bg.feather_stepmotor.description = Ansteuerung eines Schrittmotors mit dem Feather Motorshield (Anzahl der Schritte positiv und negativ)

bg.arduino_stepmotor = Stepper 
bg.arduino_stepmotor.description = Ansteuerung Schrittmotor


bg.pin-write-servo = Servo Ansteuerung 
bg.pin-write-servo.description = Drehwinkel in Grad

bg.iot_WS2812=Neopixel WS2812 
bg.iot_WS2812.description=Externe Farb-LED (Strombedarf beachten!, jedes Neopixel pro Farbe 20 mA, summiert sich).  
#bg.iot_WS2812Ring=Neopixel WS2812 Kreis
#bg.iot_WS2812Ring.description=Externe Farb-LED (Strombedarf beachten!, jedes Neopixel pro Farbe 20 mA, summiert sich). 
bg.iot_WS2812Ring_c=Neopixel WS2812 Kreis
bg.iot_WS2812Ring_c.description=Externe Farb-LED (Strombedarf beachten!, jedes Neopixel pro Farbe 20 mA, summiert sich). 


bg.LIDAR_TFmini_read =Abstand LIDAR TFmini
bg.LIDAR_TFmini_read.description = Das Blöckchen nutzt UART 

bg.calPS = PersonSensor Calibrate
bg.calPS.description = PersonSensor
bg.readPS = PersonSensor
bg.readPS.description = PersonSensor
bg.storePS = PersonSensor Store/Wipe
bg.storePS.description = PersonSensor

bg.PSVectIdent=Identify
bg.PSVectIdent.decription=Identify
bg.PSVectFace= Facing
bg.PSVectFace.decription=Facing
bg.PSVectCount=Count
bg.PSVectCount.decription=Count
bg.PSVectAll=IdentAll
bg.PSVectAll.decription=IdentAll
bg.PSVectPosX=PositionX
bg.PSVectPosX.decription=PositionX

bg.pin-read-analog121 = ADC I2C Grove
bg.pin-read-analog121.description = Erweiterung der I/O Fähigkeiten. Lese Analog-Wert via I2C (https://wiki.seeedstudio.com/Grove-I2C_ADC/)

bg.readVL53=ToF VL53L0X (mm)
bg.readVL53.description = Distance in mm



bg.GetMMA7660=3-Axis Beschleunigung MMA7660 
bg.GetMMA7660.description=Beschleunigung in 3 Achsen per I2C 


bg.pin-write-digital=digitalWrite 
bg.pin-write-digital.description=Digitaler Ausgang für GPIO-Pin festlegen

bg.pin-write-digitalLED=LED 
bg.pin-write-digitalLED.description=Digitaler Ausgang, Ansteuerung der internen LED 
 
bc.pin_number=pin 
bg.pin-write-analog=analogWrite 
bg.pin-write-analog.description=Pulsweitenmodulation (PWM) zur Ansteuerung von digitalen Aktoren (Grehzahl über H-Brücke bei Motoren, Dimmung bei LED)  
bg.iot_neopixel=Neopixel 
bg.iot_neopixel.description=Ansteuerung der internen RGB-Neopixel. Es gibt ein einfacheres Blöckchen mit den Grundfarben 
bg.iot_neopixel_light=Neopixel 
bg.iot_neopixel_light.description=Ansteuerung der internen RGB-Neopixel. Es gibt ein weiteres Blöckchen mit kontinuierlicher RGB Farbauswahl
bc.neowahl=Ort 
bc.neowahl.description=Position (Links/Rechts) 
bc.red=Rot 
bc.green=Gruen 
bc.blue=Blau 
bc.NEOVector=Farbe 
bg.NEOVectorRed=Rot 
bg.NEOVectorGreen=Grün 
bg.NEOVectorYellow=Gelb 
bg.NEOVectorBlue=Blau 
bg.NEOVectorOff=Aus 
bg.NEOVectorWhite=Weiss 
bg.neo-links=Links 
bg.neo-links.description=Links 
bg.neo-rechts=Rechts 
bg.neo-rechts.description=Rechts 
bg.iot_neowing=Neopixel Wing 
bg.iot_neowing.description=Farbansteuerung des Feather-NeopixelWing (https://www.adafruit.com/product/2945)
bg.iot_matrixwing=LED-Matrix 
bg.iot_matrixwing.description=Ausgabe auf der Charlyplex LED-Matrix (https://www.adafruit.com/product/3138) 
bc.IoTmessage=Text 
bc.IoTmessage.description=Text mit Andockstelle zum Anfügen weiterer Blöckchen 
bg.IoTmessage=Text (cat) 
bg.IoTmessage.description=Text mit Andockstelle zum Anfügen weiterer Blöckchen 
bg.connectWLANAP=WLAN
bg.connectWLANAP.description=Verbindet uns mit einem bestehenden WLAN AccessPoint 
bg.WiFiMan=WiFi Manager 
bg.WiFiMan.description=Verbindet nit dem letzten bekannten WLAN AccessPoint. Falls dieser nicht verfügbar, wird ein eigener AP geöffnet. Die SSID und das Passwort dafür wird hier definiert. Die eigentlichen WLAN Zugangsdaten werden dann mittels Handy in diesem AP definiert. 
    
bc.ssid=Netzname 
bg.ssid=Netzname 
bg.ssid.description=WLAN Netzname

bg.connectWLANAPTO=WLAN mit Timeout 
bg.connectWLANAPTO.description=Versucht eine Verbindung zum WLAN AccessPoint. Gibt es nach Ablauf des Timeouts keine Verbindung, wird false zurückgegeben. Andernfalls true 
bc.timeout=Timeout (s) 
bc.ssid.description=Timeout bei Anmeldung 
 
bc.pass=Passwort 
bg.passwort=Passwort 
bg.passwort.description=WLAN Passwort 
bg.buildWLANAP=AccessPoint 
bg.buildWLANAP.description=Spannt einen eigenen AccessPoint (analog zum Hotspot) auf.Sinnvoll in Verbindung mit dem HTTP-Server, OTA oder Shelly-Steckdosen). IP Adresse 192.168.4.1 
bg.connectGPRS=Mobilfunk-Modem 
bg.connectGPRS.description=Verbindet mit einem Mobilfunknetz 
bc.GPRSapn=APN 
bg.GPRSapn=Mobilfunk APN 
bg.GPRSapn.description=Mobilfunk APN 
bc.GPRSuser=User 
bg.GPRSuser=User 
bg.GPRSuser.description=User 
bc.GPRSpass=Passwort 
bg.GPRSpass=Passwort 
bg.GPRSpass.description=Passwort 
bg.snifferWLAN=PaxCounter 
bg.snifferWLAN.description=Zählt WiFi-Clients (Smartphones) in der Umgebung (MAC-Adressen auswerten). 
bc.snifferChannel=Channel 
bc.snifferMac=MAC Adresse 
bc.snifferRSSI =Feldstärke
bc.snifferDisplay=Anzeige
bg.snifferChannel.description=Zu überwachender WLAN Kanal. Ohne Angabe werden alle Kanäle gescannt
bg.snifferMac.description=Optional Angabe der MAC Adresse, die gesucht wird (Achtung nur bei eigenem Gerät erlaubt, Datenschutz/Privatsphäre beachten)
bg.snifferRSSI.description =Über die Feldstärke lässt sich die Entfernung (Überwachungsradius) regulieren
bg.snifferDisplay.description=Ausgabe der ersten Bytes der MAC Adresse. Es werden keine vollständigen Adressen gespeichert, nur Hash - Werte um Adressen zu zählen

bg.packetsWLAN=PacketCounter 
bg.packetsWLAN.description=Zählt alle Pakete auf dem WiFi Kanal (Auslastung)

bg.scanSSIDWLAN=SSID Beobachter
bg.scanSSIDWLAN.description=Anzeige von SSID probe requests (Datenschutz beachten)

bg.mDNS=Domain Name Service mDNS
bg.mDNS.description=Domain Name Service (.local)

 
bg.ownMessageServer=Web-Server einfach 
bg.ownMessageServer.description=HTTP-Server zur Messdatenausgabe / Matrixanzeige. IP Adresse bei eigenem Accesspoint 192.168.4.1, sonst per DHCP zugeteilt

bg.ownMessageServer_CO2=Web-Server CO2 
bg.ownMessageServer_CO2.description=HTTP-Server für Messwerte. Kalibrierfunktion nur in der Schleife / loop()! IP Adresse bei eigenem Accesspoint 192.168.4.1, sonst per DHCP zugeteilt

bg.ownMessageServer_CO2_V2=Complex Server 
bg.ownMessageServer_CO2_V2.description=HTTP-Server mit Zeitreihe. Blöckchen muss in der Schleife / loop() aufgerufen werden! IP Adresse bei eigenem Accesspoint 192.168.4.1, sonst per DHCP zugeteilt


 
bc.homepageTitle=Titel 
bg.homepageTitle=Titelzeile 
bg.homepageTitle.description=Titelzeile der Hompage 
bc.hompageSensorwahl=Anzeige 
bg.hompageMitSensor=Mit Sensoren 
bg.hompageOhneSensor=Ohne Sensoren 

bg.askGPT = ChatGPT
bg.askGPT.description = ask ChatGPT

bg.sendPhyphox=Phyphox 
bg.sendPhyphox.description=Übermittelt Messwerte an die Phyphox App. Anleitung: https://www.umwelt-campus.de/iot-werkstatt/tutorials-1/app-phyphox


bg.sendThingspeak=Thingspeak, send 
bg.sendThingspeak.description=Übermittelt Messwerte an die Thingspeak Cloud. Der <API-Key> wird nach Anmeldung beim Thingspeak Server über cut&paste übernommen. Für Free-accounts gilt ein Update-Zyklus von mindestens 15 s 
bc.host=Server 
bg.host=Servername 
bg.host.description=Servername 
bc.apikey=API-Key 
bg.apikey=API-Key 
bg.apikey.description=geheimer eigener API-Key / Passwort 
bc.thing1=Feld 1 
#bg.thing1=Messwert 
#bg.thing1.description=Messwert Feld 1 
bc.thing2=Feld 2 
#bg.thing2=Messwert 
#bg.thing2.description=Messwert Feld 2 
bc.thing3=Feld 3 
#bg.thing3=Messwert 
#bg.thing3.description=Messwert Feld 3 
bc.thing4=Feld 4 
#bg.thing4=Messwert 
#bg.thing4.description=Messwert Feld 4 
bc.thing5=Feld 5 
#bg.thing5=Messwert 
#bg.thing5.description=Messwert Feld 5 
bc.thing6=Feld 6 
#bg.thing6=Messwert 
#bg.thing6.description=Messwert Feld 6 
bc.thing7=Feld 7 
#bg.thing7=Messwert 
#bg.thing7.description=Messwert Feld 7 
bc.thing8=Feld 8 
#bg.thing8=Messwert 
#bg.thing8.description=Messwert Feld 8 

bg.askThingspeak=Thingspeak, read 
bg.askThingspeak.description=Abfrage eines aktuellen Messwertes im Thingspeak Kanal. Der <Kanal> ist die Channel-ID beim Server (thingspeak.com). Steht dort z.B. in der URL bei der Visualisierung der Daten. Der Channel muss public sein, d.h. für alle sichtbar. 
bc.channel=Kanal 
bc.channel.description=Channel ID im Thingspeak 
bc.feld=Feldindex 
bc.feld.description=Index Field 

#bg.sendHeruko=heruko 
#bg.sendHeruko.description=sends values to heruko 

bg.sendThingsboard=Thingsboard, send  
bg.sendThingsboard.description=Sendet JSON Daten an die thingsboard cloud. Es gibt ein weiteres Blöckchen zur Erzeugung eines JWT Tokens zur Authorisierung 

bg.askThingsboard=Thingsboard, read 
bg.askThingsboard.description=Lädt JSON Daten aus der thingsboard cloud. Anschließend mit dem JSON Blöckchen auswerten. 


bg.sendSensebox=OpenSenseMap.org
bg.sendSensebox.description = Sende Daten an die Geo-Cloud von OpenSenseMap.org.Die <Box-ID> und <Sensor-ID> wird nach Anmeldung am Server vergeben. 

bg.sendLuftdaten=Sensor.community
bg.sendLuftdaten.description = Sende Daten an die Geo-Cloud von Sensor.community. Die <Sensor-ID> wird nach Anmeldung am Server vergeben.

bg.sendIFTTT2=If This Then That (IFTTT.com)
bg.sendIFTTT2.description=Auslösen eines If This Then That Ereignisses 
bg.trigger=Trigger 
bg.trigger.description=Name des IFTTT Triggers 
bc.key=Key 
bg.key=Key 
bg.key.description=IFTTT Key 

bg.requestJWT=request JWT 
bg.requestJWT.description=authentication JSON Web Token 

bg.sendHTTPSGet=http(s) GET 
bg.sendHTTPSGet.description=REST Protocol GET 
bg.JSONGet=JSON 
bg.JSONGet.description=search item 
bg.EcoflowGet=Ecoflow 
bg.EcoflowGet.description=REST Protocol GET 


bg.sendHTTPGet=http GET 
bg.sendHTTPGet.description=REST Protokoll, HTTP-GET. Es gibt ein eigenes JSON-Blöckchen zur Auswertung der Antwort 


bg.NOWShowMAC=Show my own MAC
bg.NOWShowMAC.description=shows own MAC Adress
bg.NOWSendPeer=Send to NOW Peer
bg.NOWSendPeer.description=send message to peer
bg.NOWReceive=Receive from NOW Peer
bg.NOWReceive.description=receive message from now
bg.NOWPayloadStr=Payload Text
bg.NOWPayloadStr.description=Payload Text



bg.LEDShelly=Shelly LED
bg.LEDShelly.description=Ändert die Beleuchtung des farbigen Rings am Shelly Plus (soweit nicht intern übersteuert)
bg.sendShelly=Shelly Switch
bg.sendShelly.description=Schaltet die Shelly Steckdose Gen 1 und 2 (https://kb.shelly.cloud/knowledge-base/shelly-plus-plug-s-1)
#bg.getShelly=Shelly Meter
#bg.getShelly.description=power meter
bg.getShelly2=Shelly Meter
bg.getShelly2.description=Leistungs und Energiemessung mit dem Shelly Plug. Ein Shelly Plug der ersten Generation kann nur Leistung messen
bc.ShellyVector=Val
bc.ShellyVector.description=measurement
bg.ShellyVectorPower=Leistung [W] 
bg.ShellyVectorPower.description=power meter
bg.ShellyVectorTotal=Energie [Wh] 
bg.ShellyVectorTotal.description=power meter
bg.ShellyVectorTemp=Temperature [C] 
bg.ShellyVectorTotal.description=power meter
bc.ShellyVectorGen=Generation 
bc.ShellyVectorGen.description=power meter

bg.ShellyVectorGen1=Shelly (Gen. 1) 
bg.ShellyVectorGen1.description=Erste Version (geriffeltes Gehäuse)

bg.ShellyVectorGen2=ShellyPlus (Gen. 2)
bg.ShellyVectorGen2.description=Zweite Eneration (glattes Gehäuse)
bg.sendInfluxDB=InfluxDB send  
bg.sendInfluxDB.description=Sende Daten an die Datenbank 
bg.createInfluxDB=InfluxDB create 
bg.createInfluxDB.description=Erstelle Zugangsdaten  

bg.createEDGE=EDGE IMPULSE create 
bg.createEDGE.description=Erstellt Informationen zur Datenbasis. Siehe https://www.umwelt-campus.de/iot-werkstatt/tutorials-1/edge-ki-edge-impulse-cloud 

bg.sampleEDGE=EDGE IMPULSE sample 
bg.sampleEDGE.description=Sammelt Daten im Datenfeld (max. 50 Messzeitpunkte a maximal 4 Sensoren). Siehe https://www.umwelt-campus.de/iot-werkstatt/tutorials-1/edge-ki-edge-impulse-cloud

bg.sendEDGE=EDGE IMPULSE send 
bg.sendEDGE.description=Sende die Daten zur Bearbeitung in die Cloud (https://edgeimpulse.com/) 

bg.classifyEDGE=EDGE IMPULSE inference 
bg.classifyEDGE.description=Klassifikation / Regression über eine Bibliothek von EDGE_IMPULSE. Nach Lösung der KI-Aufgabe in der Cloud den Algorithmus in Form der Bibliothek von dort herunterladen. (https://edgeimpulse.com/) 

bg.classifyEDGEc =classification
bg.classifyEDGEr =regression


bg.sampleClass=EDGE sample
bg.sampleClass.description=Erfasst Trainingsdaten (Lernstichprobe) für den Nächsten-Nachbar-Klassifikator oder die Regression. Maximal 50 Datenpunkte a maximal 3 Sensoren. Um bei der Regression eine automatische Modellentscheidung zur ermöglichen, wird zwischen Kalibier- und Validierdaten unterschieden 

bg.detClass=EDGE classify NN
bg.detClass.description=Klassifiziere die Daten anhand des trainierten NN-Klassifikators aus der Lernstichprobe (Kalibrierdaten)


bg.AIDatatypVal =Validierdaten
bg.AIDatatypCal =Kalibrierdaten

bg.AIcaliRegModel=EDGE calibrate
bg.AIcaliRegModel.description=Bestimme die Modellparameter der ausgewählten Regressionsmodelle. Nutzt die Kalibrierdaten. 

bg.AIselectRegModel=EDGE select model
bg.AIselectRegModel.description=Wählt auf der Grundlage der gewählten Daten das beste Regressionsmodell aus

bg.AIcalcRegModel=EDGE apply
bg.AIcalcRegModel.description=Wendet das trainierte Regressionsmodell an

bg.AIcaliRegModel=EDGE calibrate
bg.AIcaliRegModel.description=Bestimme die Modellparameter der ausgewählten Regressionsmodelle. Nutzt die Kalibrierdaten. 

bg.AIModeltypAuto=all/auto
bg.AIModeltypLin =linear
bg.AIModeltypQuad=quadratic
bg.AIModeltypCub =cubic
bg.AIModeltypExp =exponential

bg.text=Text 
bg.URI=URI 
bc.URI=URI 
bg.URI.description=Kommando 
bg.port=Port 
bc.port=Port 
bg.port.description=Port Nummer (80, 8080) 

bg.sendBlynk=Blynk-VirtualWrite 
bg.sendBlynk.description=Übermittelt Werte an Blynk-Cloud (https://blynk.cloud) 

bg.readBlynk=Blynk-VirtualRead 
bg.readBlynk.description=Übermittelt Werte von Blynk-Cloud (https://blynk.cloud)

bg.payloadStrBlynk=Payload Text
bg.payloadStrBlynk.description=Übertragende Payload-Daten (interpretiert als Text)
bg.payloadIntBlynk=Payload Integer
bg.payloadIntBlynk.description=Übertragene Payload-Daten (interpretiert als Integer)
bg.payloadFloatBlynk=Payload Float
bg.payloadFloatBlynk.description=Übertragene Payload-Daten (interpretiert als Float)

bg.connectBlynk=Blynk-Cloud 
bg.connectBlynk.description=Konfiguration Blynk (https://blynk.cloud)


bg.mqttconnect=mqtt 
bg.mqttconnect.description=connect, Verbindung mit MQTT-Broker 
bc.mqttbroker=Broker 
bg.mqttbroker.description=URL MQTT-Broker 
bg.mqttbroker=mqtt broker 
bc.mqttclient=Client 
bg.mqttclient=Client 
bg.mqttclient.description=Name des MQTT-Clients 
bg.mqttclient=mqtt client 
bg.mqttclient.description=Name des eigenen MQTT-Clients 
bg.mqttpublish=mqtt publish 
bg.mqttpublish.description=Nachricht an den Broker senden. Das <Retained>-Flag sorgt dafür, dass die letzte gesendete Nachricht eines Topics auf dem Broker gespeichert bleibt und sofort an neue Abonnenten gesendet wird, sobald sie sich anmelden.  
bc.mqtttopic=Topic 
bg.mqtttopic=Topic 
bg.mqtttopic.description=mqtt topic, Bezeichnung der Nachricht 
bg.mqttpayload=mqtt payload 
bg.mqttpayload.description=Inhalt der Nachricht (Payload) 
bg.mqttsubscribe=mqtt subscribe 
bg.mqttsubscribe.description=Subscribe, abonniert Nachricht beim Broker. Führt <callback> aus, falls neue Nachrichten eintreffen. <QoS>: (Quality of Service) definiert die Zuverlässigkeit der Nachrichtenübertragung und bestimmt, ob Nachrichten einmal (QoS 0), mindestens einmal (QoS 1) oder genau einmal (QoS 2) zugestellt werden. 
bc.mqttpayload=Payload 
bc.mqttcallback=callback 
bg.mqttcallback=callback 
bg.mqttcallback.description=Subscribe Callback function. Wird aufgerufen, wenn es eine neue Nachricht gibt. Bitte keine blockierenden Befehle verwenden.  

bg.sendTTN_RFM95_ota=TTN (OTAA) 
bg.sendTTN_RFM95_ota.description=Blöckchen veraltet, bitte ersetzen 
bg.sendTTN_RFM95_ota2=TTN (OTAA) 
bg.sendTTN_RFM95_ota2.description=Übermittelt Messwerte an TTN, verwendet otaa-Protokoll. Die Keys werden bei der Device Registration im TTN-Netz erstellt und per Cut&Paste übernommen. <Port> und <Felder> sind frei zu wählen. Hardware RFM95 (FeatherWing mit SX1276). Weitere Info: https://id.thethingsnetwork.org TxSF ist SpreadingFactor beim senden von Daten. OTA Join startet mit SF10. Bei SF=Auto (ADR on) stuft das Netz ggf. bis auf SF7 runter. Das spart erheblich Airtime und Energie. Bei 4 Datenfeldern (a 3 Byte) sind bei SF10 etwa 3 Nachrichten pro Stunde erlaubt. Bei SF7 wären es 40 pro Stunde.
bg.TTN_SF_Auto = Auto (ADR on, max SF10)
bg.TTN_SF_Auto.description = Netz wählt die optimale Datenrate selber (empfohlen)
bg.TTN_SF7 = DR_SF7 (ADR off)
bg.TTN_SF7.description = SF 7, lowest airtime, each datavalue decoded with 4 bytes, https://avbentem.github.io/airtime-calculator/ttn/eu868
bg.TTN_SF8 = DR_SF8 (ADR off)
bg.TTN_SF8.description = SF8, middle airtime, each datavalue decoded with 4 bytes, https://avbentem.github.io/airtime-calculator/ttn/eu868
bg.TTN_SF9 = DR_SF9 (ADR off)
bg.TTN_SF9.description = SF9, middle airtime, each datavalue decoded with 4 bytes, https://avbentem.github.io/airtime-calculator/ttn/eu868
bg.TTN_SF10 = DR_SF10 (ADR off)
bg.TTN_SF10.description = SF10, high airtime, each datavalue decoded with 4 bytes, https://avbentem.github.io/airtime-calculator/ttn/eu868
bg.TTN_SF11 = DR_SF11 (ADR off)
bg.TTN_SF11.description = SF11, highest airtime, each datavalue decoded with 4 bytes, https://avbentem.github.io/airtime-calculator/ttn/eu868
bg.TTN_SF12 = DR_SF12 (ADR off)
bg.TTN_SF12.description = SF12, highest airtime, each datavalue decoded with 4 bytes, https://avbentem.github.io/airtime-calculator/ttn/eu868




bc.TTN_DEVEUI=Dev EUI 
bg.TTN_DEVEUI=Dev EUI 
bg.TTN_DEVEUI.description=TTN Device EUI (8 Byte) 
bc.TTN_APPEUI=App EUI 
bg.TTN_APPEUI=App EUI 
bg.TTN_APPEUI.description=TTN Application EUI (8 Byte) 
bc.TTN_APPKEY=App Key 
bg.TTN_APPKEY=App Key 
bg.TTN_APPKEY.description=TTN Application Key  (16 Byte) 
bc.TTN_PORT=Port 
bg.TTN_PORT=Port 
bg.TTN_PORT.description=TTN Message Port 
bg.sendTTN_RFM95_abp=TTN (ABP) 
bg.sendTTN_RFM95_abp2=TTN (ABP) 
bg.sendTTN_RFM95_abp2.description=Übermittelt Messwerte an TTN, verwendet dabei das abp-Protokoll. Die Keys werden bei der Device Registration im TTN-Netz erstellt und per Cut&Paste übernommen. <Port> und <Felder> sind frei zu wählen. Hardware RFM95 (FeatherWing mit SX1276). Weitere Info: https://id.thethingsnetwork.org TxSF ist SpreadingFactor beim senden von Daten. Bei SF=Auto (ADR on) senden wir mit SF8, das Netz kann je nach Bedarf hoch oder runterstufen. Das spart erheblich Airtime und Energie. Bei 4 Datenfeldern (a 3 Byte) sind bei SF10 etwa 3 Nachrichten pro Stunde erlaubt. Bei SF7 wären es 40 pro Stunde. 
bg.sendTTN_RFM95_abp.description=Blöckchen veraltet, bitte ersetzen 


bc.TTN_DEVADD=Dev Addr 
bg.TTN_DEVADD=Dev Addr 
bg.TTN_DEVADD.description=TTN Device Adress (4 Byte) 
bc.TTN_NETSKEY=NetS Key 
bg.TTN_NETSKEY=NetS Key 
bg.TTN_NETSKEY.description=TTN Network Session Key (16 Byte) 
bc.TTN_APPSKEY=AppS Key 
bg.TTN_APPSKEY=AppS Key 
bg.TTN_APPSKEY.description=TTN Application Session Key  (16 Byte) 
bg.TTN_RxCallback=TTN RxCallback 
bg.TTN_RxCallback.description=Über diesen Block lassen sich Nachrichten (Payload) vom TTN-Gateway auswerten.  Nach dem Senden eines Messwertes schaltet der Mikrocontroller kurz auf Empfang. Damit können wir auch "Befehle von oben" empfangen. 

bg.NTP= Uhrzeit, Abfrage Network Time Protokoll
bg.NTP.description = Uhrzeit Service, stellt die intere Uhr über Abruf von einem NTP-Server 

bg.NTPctime= Uhrzeit als Text
bg.NTPctime.description = Uhrzeit als Text 

bg.NTPunix= Uhrzeit Now (Unix-Time)
bg.NTPunix.description = Uhrzeit als Sekunden seit 1970 

bg.SMTP_Config=E-mail config
bg.SMTP_Config.description= SMTP E-mail, see https://randomnerdtutorials.com/esp32-send-email-smtp-server-arduino-ide/ 
bg.SMTP_Send=E-mail send
bg.SMTP_Send.description= SMTP E-mail, see https://randomnerdtutorials.com/esp32-send-email-smtp-server-arduino-ide/ 

bg.Whatsup_Send= Whatsup
bg.Whatsup_Send.description = whatsup messenger via callmebot API, see https://randomnerdtutorials.com/esp32-send-messages-whatsapp/


bg.SAM_Say= Audio Say
bg.SAM_Say.description = synthetische Sprache, see https://github.com/earlephilhower/ESP8266SAM

bg.SAM_Conf= Spracheinstellung
bg.SAM_Conf.description = Konfiguration Sprechende, see https://github.com/earlephilhower/ESP8266SAM

bg.WebRadio= WebRadio
bg.WebRadio.description = Play Webradio, Lautstärke gain 0-100 %, see https://github.com/earlephilhower/ESP8266Audio
bg.WebRadioStreamTitle= WebRadio Title
bg.WebRadioStreamTitle.description = Play Webradio, Songtitel


bg.BuzzerSong= Play Buzzer Song
bg.BuzzerSong.description= play buzzer music 
bg.BuzzerTone= Play Buzzer Tone
bg.BuzzerTone.description= play buzzer tone 

bc.BuzzerVector=song
bc.BuzzerVector.description=music 
bg.Buzzer0=Happy Birthday
bg.Buzzer1=Harry Potter
bg.Buzzer2=Pirate des Caraïbes
bg.Buzzer3=Star Wars
bg.Buzzer4=Entertainement
bg.Buzzer5=BarbieGirl
bg.Buzzer0.description=song
bg.Buzzer1.description=song
bg.Buzzer2.description=song
bg.Buzzer3.description=song
bg.Buzzer4.description=song
bg.Buzzer5.description=song

bg.MIC_Loudness = Mikrofon Lautstärke
bg.MIC_Claps = Klatsch-Sensor
bg.MIC_Loudness.description = Ermittelt die Lautstärke im Raum (0 .... 4095). Beim Setup wird für 1 Sekunde die Ruhelinie ermittelt
bg.MIC_Claps.description = Zählt Klatscher. Min/Max Pause definiert die minimalen bzw. maximalen Abstände der Klatscher (in s). Level die Lautsärke, ab dem die Klatscher gezählt werden.
bg.MIC_Fourier = Mikrofon FourierMag
bg.MIC_Fourier.description = Betrag des Fourierkoeffizienten für eine bestimmte Frequenz in dB (Goertzel Algorithmus). Teste mit https://onlinetonegenerator.com
bg.MIC_YIN = Mikrofon Frequenzschätzung
bg.MIC_YIN.description = Frequency Estimator (YIN-Algorithmus), teste mit https://onlinetonegenerator.com , Alain de Cheveigné & Hideki Kawahara (2002)


bg.sleep=deep Sleep 8266 
bg.sleep.description=Tiefschlaf für <ms> Millisekunden, danach Neustart mit (true) oder ohne (false) WLAN aktiv. Alle GPIOs verlieren ihren elektischen Pegel. 
bg.sleepRF=WLAN RF 
bg.sleepRF.description=Aufwachen mit (true) oder ohne (false) WLAN 
bc.sleepRF=WLAN RF 
bg.sleepRF=WLAN RF 
bg.sleepRF.description=Aufwachen mit (true) oder ohne (false) WLAN

bg.LightSleep=light sleep 8266 
bg.LightSleep.description=sleeps milliseconds

bg.sleep32=deep sleep 32 
bg.sleep32.description=Tiefschlaf für <ms> Millisekunden. Achtung: GPIO Ausgänge floaten. Um diese zu fixieren gibt es ein gesondertes Blöckchen (RTC_GPIO). Nach Ablauf der <ms> gibt es einen Deepsleep-Reset, d.h. das Programm startet neu.
bg.LightSleep32=light sleep 32 
bg.LightSleep32.description=Schlafe für <ms> Millisekunden. GPIO Ausgänge bleiben aktiviert, Uhr läuft weiter. Nach Ablauf der <ms> läuft das Programm wie gewohnt weiter 
bg.Frequency32=Frequency 32
bg.Frequency32.description=Ändert die CPU-Frequenz <f> in in MHz. Typische Werte 80, 160 oder 240 MHz. Kleinst möglicher Wert 10 MHz (energiesparend, aber kein WLAN, kein I2C) 
bg.RTC_GPIO32=set RTC_GPIO 
bg.RTC_GPIO32.description=Normale GPIOs verlieren im Tiefschlaf ihren elektrisches Potential. RTC-GPIOs können den Pegel auf den im <level> angegebenen Zustand stabilisieren. Beim ESP32 WROOM ist die für folgende GPIOs möglich: GPIO 0, GPIO 2, 4, 12-15, 25-27, 32-36, 39.
bg.RTC_GPIO32_low    = LOW
bg.RTC_GPIO32_high   = HIGH
bg.RTC_GPIO32_float  = FLOAT 


bg.modemSleep=modem sleep
bg.modemSleep.description=Schaltet das WiFi-Modem aus (energy saving) 
bg.I2CScan=I2C address scan
bg.I2CScan.description=Listet Komponenten am I2C-Bus 

bg.analogReadmV_32=analogRead_mV
bg.analogReadmV_32.description = Liest die Spannung am Eingang Ai. Maximal 3.3V, werks-kalibriert im Bereich 0 bis 3100 mV

bg.readReset=ResetInfo 8266 
bg.readReset.description=Gibt den Grund für einen Neustart aus. Blöckchen am Anfang des setup() verwenden.  
bg.readReset32=ResetInfo 32 
bg.readReset32.description=Gibt den Grund für einen Neustart aus. Bsp. Reason 8 bei Aufwachen nach deepsleep. Reason 1 bei PowerUp. Blöckchen am Anfang des setup() verwenden.  
bg.readVCC=BatteryVCC 8266 
bg.readVCC.description=switch adc to VCC, disable analogRead   
bg.WiFiEnable=WiFi Enable 
bg.WiFiEnable.description=Switch Modem 

bg.basicOTA=OTA (On the Air Update)
bg.basicOTA.description=Ermöglicht on the air update. Aufspielen neuer Software per WLAN. Dazu müssen sich Client und Server im gleichen WLAN-Netz befinden. Das Blöckchen muss zyklisch aufgerufen werden (z.B. in einer Schleife) 

bg.RTCtoRTCMem=Save StaticVar to RTCMem 8266 
bg.RTCtoRTCMem.description=save array to RTC-RAM 

bg.RTCfromRTCMem=Load StaticVar from RTCMem 8266 
bg.RTCfromRTCMem.description=load array from RTC-RAM 

bg.RTCtoEEPROM=Save StaticVar to EEPROM 8266 
bg.RTCtoEEPROM.description=save RTC-RAM to EEPROM 

bg.RTCfromEEPROM=Load StaticVar from EEPROM 8266 
bg.RTCfromEEPROM.description=get RTC-RAM from EEPROM 

bg.readRTCVarNum=Read StaticVar 8266 
bg.readRTCVarNum.description=read Value vom Array 

bg.setRTCVarNum=Set StaticVar 8266 
bg.setRTCVarNum.description=set Value to Array 

bg.RTCCheck=Check StaticVar valid 8266 
bg.RTCCheck.description=CRC32 from RTCVar-Array

bg.irqAttach=irq attach
bg.irqAttach.description=subscribe, subscribe message n=subscribe, subscribe message 

bg.irqModeChange=CHANGE
bg.irqModeChange.description=irq mode 
bg.irqModeRising=RISING
bg.irqModeChange.description=irq mode 
bg.irqModeFalling=FALLING
bg.irqModeChange.description=irq mode 

bc.irqISR=ISR 
bg.irqISR=ISR 
bg.irqISR.description= interrupt service routine 

bg.irqEnable=global irq 
bg.irqEnable.description= enable/disable global interrupt 

bg.irqDetach=irq detach 
bg.irqDetach.description= detach interrupt 

bg.timerAttach=timer attach 
bg.timerAttach.description= timer callback 

bg.timerDetach=timer detach 
bg.timerDetach.description= detach timer callback 

bg.freeRTOS_task =
bg.freeRTOS_task.description=Erzeugt und startet eine FreeRTOS-Task. Setup wird einmalig ausgef\u00fchrt, anschließend folgt die Endlosschleife.

bg.freeRTOS_task =
bg.freeRTOS_task.description=Erzeugt und startet eine FreeRTOS-Task. Setup wird einmalig ausgef\u00fchrt, anschließend folgt die Endlosschleife.

bg.freeRTOS_semaGive = SemaGive
bg.freeRTOS_semaGive.description=Erzeugt einen FreeRTOS Mutex und gibt ihn frei

bg.freeRTOS_semaTake = SemaTake
bg.freeRTOS_semaTake.description=Erzeugt einen FreeRTOS Mutex und gibt blockiert ihn

bg.freeRTOS_vTaskDelay = TaskDelay
bg.freeRTOS_vTaskDelay.description=Wartet ms ohne CPU zu blockieren


bd.control=Kontrollstrukturen 
bd.control.description=Alles was den Programmablauf steuert. Fallunterscheidungen, Wiederholungen, Unterprogramme, Wartepausen. Beispiele hier: https://www.umwelt-campus.de/iot-werkstatt/tutorials/umweltsensorik-laermampel-luegendetektor-und-raumklima

bd.logic=Logische Vergleiche 
bd.logic.description=Alle Vergleichsoperationen. Ob irgend etwas größer oder kleiner als eine Zahl ist und logische Verknüpfungen  

bd.operators=Math. Operationen 
bd.operators.description=Alles dreht sich um Zahlen und Berechnungen. 

bd.number=Variablen / Konstanten 
bd.number.description=Hier finden sich die Speichergefäße für Informationen. 

bd.ser_communication=Print / Adapter 
bd.ser_communication.description=Ausgaben auf den seriellen Monitor z.B. zur Kontrolle des Programmablaufs. Auch Adapter (Typcast) für die verschiedenen Datentypen finden sich hier.

bd.input=Sensoren 
bd.input.description=Alle auf dem Board integrierten Sensoren, Analog Digital-Wandlung, Encoder-Knopf. Weitere Sensoren finden sich im Werkzeugkasten "Externe Interfaces"  

bd.signal=Signalverarbeitung
bd.signal.description=Algorithmen, die Messgrößen filtern oder verarbeiten. Vom Medianfilter, Mapping bis zur Berechnung der absoluten Luftfeuchte 

bd.input_ext=Externe Interfaces 
bd.input_ext.description=Alles was an Peripherie über die Grove-Buchsen angesteckt werden kann. Motoren, Anzeigen, weitere Sensoren 

bd.output=Anzeigen / Aktoren  
bd.output.description=Auf dem Board integrierten Anzeigen (OLED-Display, Neopixel) und digitale Eingänge (Drück-Mich-Knopf)  

bd.WLAN_communication=IoT: WiFi 
bd.WLAN_communication.description=Unsere Verbindung zum Internet der Dinge (WLAN Ankopplung, Hotspot). Beispiele hier: https://www.umwelt-campus.de/iot-werkstatt/tutorials/klassenklima-umweltdaten-im-web-server

bd.HTTP_communication=IoT: HTTP
bd.HTTP_communication.description=Kommunikationsprotokolle für viele Cloud-Plattformen (Thingspeak, Thingsboard, OpenSenseMap), Shelly. Beispiele hier: https://www.umwelt-campus.de/iot-werkstatt/tutorials/schulklima-messdaten-in-der-thingspeak-cloud

bd.MQTT_communication=IoT: MQTT 
bd.MQTT_communication.description=Das verbreiteteste Protokoll für das IoT, spricht mit dem MQTT-Broker. Beispiel gefällig: https://www.umwelt-campus.de/iot-werkstatt/tutorials/internet-of-everything-octopus-trifft-ifttt-mqtt-und-alexa-im-smart-home 

bd.LORA_communication=IoT: LoRaWAN 
bd.LORA_communication.description=Falls es im Feld keinen Internetzugang gibt. Nutzt Frequenzen des Babyphones um größere Strecken zu überbrücken. Beispiele hier: https://www.umwelt-campus.de/iot-werkstatt/tutorials/mitmachklima-lorawan-als-offenes-netz-zur-daseinsvorsorge 

bd.Blynk_communication=IoT: Blynk
bd.Blynk_communication.description=Eine Cloud-Anwendung für einfache Smartphone-Apps. Beispiel gefällig: https://www.umwelt-campus.de/iot-werkstatt/tutorials/internet-of-everything-blynk-die-smartphone-app

bd.ESPNow=IoT: ESP-NOW
bd.ESPNow.description=Proprietäres Protokoll zur Kommunikation zwischen Octopus und Makey.  

bd.database=IoT: EDGE KI  
bd.database.description=Alles für die künstliche Intelligenz und die Ankopplung an Datenbanken. Ein Beispiel: https://www.umwelt-campus.de/iot-werkstatt/tutorials/apfelki  

bd.WLAN_NTP = IoT: E-mail / NTP
bd.WLAN_NTP.description = E-mail und Network Time Protocol. Ermöglicht die Abfrage der aktuellen Uhrzeit

bd.WLAN_privacy=IoT: Privatsphäre 
bd.WLAN_privacy.description=IoT weiß alles - nutze den Pax-Counter um Personen (Smartphones) zu zählen. Beispiele hier: https://www.umwelt-campus.de/iot-werkstatt/tutorials/privatsphaere-mit-ueberwachung-das-klima-retten

#bg.dummy=dummy
bd.MINT=IoT: MINT
bd.MINT.description=CO2-Ampel, Absorptions-Spektrometer oder Balkonkraftwerk. Beispiel hier: https://www.umwelt-campus.de/iot-werkstatt/tutorials/klimaschutz-iot-stromboerse-und-co2

bd.MED=IoT: COVID-19
bd.MED.description=IoT: COVID-19

bd.ESP_irq=Timer / Interrupts
bd.ESP_irq.description=Für Fortgeschrittene: Einstieg in die Echtzeitverarbeitung. Interrupts reagieren asynchron auf externe Ereignisse. Timer starten periodisch nebenläufige Programmteile  

bd.ESP_system  =ESP8266: Octopus 
bd.ESP_system.description  =Für Fortgeschrittene: Systembefehle für den ESP8266 (Deep-Sleep, Rest, RTC-Memory & Co.) 

bd.ESP32_system=ESP32: Makey 
bd.ESP32_system.description=Für Fortgeschrittene: Systembefehle für den ESP32 (Light-Sleep, Deep-Sleep, RTC, Reset & Co.)
