#X-Generator: crowdin.com
ardublock.file.suffix=Ardublock Programmdatei (*.abp)
ardublock.ui.new=Neu
ardublock.ui.save=Speichern
ardublock.ui.debug=Testausgaben
ardublock.ui.debug0=Debug: No
ardublock.ui.debug1=Debug: Normal
ardublock.ui.debug2=Debug: Detailliert



ardublock.ui.saveAs=Speichern als
ardublock.ui.load=\u00d6ffnen
ardublock.ui.upload=Upload IDE 1
ardublock.ui.generate=Generate File
ardublock.ui.clone=Klonen
ardublock.ui.add_comment=Kommentar hinzuf\u00fcgen
ardublock.ui.delete_comment=Kommentar l\u00f6schen
ardublock.ui.organize_blocks=Alle Bl\u00f6cke neu anordnen
ardublock.ui.create_refer=Verweis erstellen
ardublock.ui.website=Webseite
ardublock.ui.serialMonitor=Monitor
ardublock.ui.saveImage=Bild


ardublock.translator.exception.noLoopFound=Kein Programmrumpf gefunden\!
ardublock.translator.exception.multipleLoopFound=Mehrere Programmbl\u00f6cke gefunden\!
ardublock.translator.exception.subroutineNotDeclared=Das Unterprogramm ist nicht deklariert

message.title.error=Fehler
message.title.question=Frage
message.content.open_unsaved=Das Ardublock-Programm hat sich ge\u00e4ndert, m\u00f6chten Sie es vorher speichern?
message.content.overwrite=M\u00f6chten Sie die vorhandene Datei \u00fcberschreiben?
message.file_not_found=Datei wurde nicht gefunden oder der Zugriff wurde verweigert
#message.question.newfile_on_workspace_changed=Das aktuelle Programm hat sich ge\u00e4ndert, m\u00f6chten Sie trotzdem eine neue Ardublock-Datei erstellen?
message.question.newfile_on_workspace_changed=Das Programm hat sich ge\u00e4ndert, m\u00f6chten Sie es vorher speichern?

message.question.newboard=Das Board hat sich ge\u00e4ndert, m\u00f6chten Sie eine neue Ardublock-Datei erstellen?
message.question.exit=Das Programm hat sich ge\u00e4ndert, m\u00f6chten Sie das Fenster wirklich schließen?

ardublock.translator.exception.subroutineNameDuplicated=Zwei oder mehr Unterprogramme haben den selben Namen
ardublock.translator.exception.noLoopFound=Keine loop gefunden!
ardublock.translator.exception.socketNull=Ein ben\u00f6tigter Wert oder eine Variable fehlt.\nHinweis:: Beachte den Anschlussteil (Schloss) im markierten Block

bg.Divider_Display    =------  Anzeigen   -----------
bg.Divider_Environment=------  Luft       -----------
bg.Divider_Distance   =------  Abstand    -----------
bg.Divider_Light      =------  Licht, Farbe ---------
bg.Divider_Expand     =------  I/O, ADC   -----------
bg.Divider_GPS        =------  GPS        -----------
bg.Divider_LED        =------  LED        -----------
bg.Divider_Motor      =------  Motor      -----------
bg.Divider_Div        =------  Diverses   -----------
bg.Divider_NFC        =------  NFC / RFID -----------
bg.Divider_Bool       =------  Wahrheitswerte -------
bg.Divider_Num        =------  Zahlen     -----------
bg.Divider_String     =------  Text       -----------
bg.Divider_Predef     =------  Compiler Flags -------
bg.Divider_Time       =------  Aktuelle Zeit --------
bg.Divider_Array      =------  Datenfeld  -----------

bg.Divider_Math       =------  Mathematik -----------


bg.Divider_Loop       =------  Scheifen   -----------
bg.Divider_Case       =------  Fallunterscheidung  --
bg.Divider_UP         =------  Unterprogramm  -------
bg.Divider_Wait       =------  Warten     -----------
bg.Divider_Code       =------  C-Code     -----------

bg.Divider_Test       =------  Vergleiche -----------
bg.Divider_Logic      =------  Logische Verknüpfung -
bg.Divider_Print      =------  Ausgabe ser. Monitor -
bg.Divider_Type       =------  Adapter (Typecast) ---
bg.Divider_Encoder    =------  Manuelle Eingabe  ----

bg.Divider_WiFi       =------  WLAN Client  ---------
bg.Divider_WiFiAP     =------  WLAN Hotspot ---------
bg.Divider_DNS        =------  DNS NameServer -------
bg.Divider_Server     =------  Eigener HTTP Server --
bg.Divider_Thing      =------  Thingspeak Cloud  ----
bg.Divider_Sense      =------  Umweltdaten Cloud ----
bg.Divider_Weight     =------  Gewicht, Kraft    ----
bg.Divider_Energy     =------  Energie Cloud     ----
bg.Divider_Smart      =------  Smart Home Cloud  ----
bg.Divider_Generic    =------  Universal Cloud   ----
bg.Divider_MQTT       =------  MQTT IoT-Cloud    ----
bg.Divider_LoRa       =------  LoRaWAN IoT-Cloud ----
bg.Divider_Blynk      =------  Blynk App-Cloud   ----

bg.Divider_Privacy    =------  Privatsphäre ---------
bg.Divider_Signal     =------  Signalverarbeitung ---

bg.Divider_ChatGPT    =------  Generative KI      ---
bg.Divider_KNN        =------  NN-Klassifikator   ---
bg.Divider_Reg        =------  Regressions Modell ---
bg.Divider_EDGE       =------  EDGE-KI Cloud      ---
bg.Divider_INFLUX     =------  InfluxDB           ---

bg.Divider_CO2        =------  CO2-Ampel    ---------
bg.Divider_Spektro    =------  Spektrometer ---------
bg.Divider_Balkon     =------  Balkonsolar  ---------
bg.Divider_IRQ        =------  Interrupt / Timer  ---
bg.Divider_ESP32      =------  System ESP32       ---
bg.Divider_ESP8266    =------  System ESP8266     ---
bg.Divider_RTC        =------  RTC / EEPROM       ---
bg.Divider_OTA        =------  OTA Update         ---



bg.program= 
bg.program.description=Rumpf f\u00fcr das Hauptprogramm beim Arduino. Setup wird einmalig ausgef\u00fchrt, dann folgt die Endlosschleife.
#bg.debugprogram= 
#bg.debugprogram.description=Rumpf f\u00fcr das Hauptprogramm beim Arduino. Setup wird einmalig ausgef\u00fchrt, dann folgt die Endlosschleife. Testausgaben erfolgen am seriellen Monitor in der Arduino IDE
bc.setup=Setup 
bg.setup=setup 
bc.loop=Schleife 
bg.loop=Wiederhole fortlaufend 
bg.loop.description=Schleife mit automatischem Setup 
bg.repeat_times=Wiederhole 
bg.repeat_times.description=Wiederhole die Befehle genau eine bestimmter Anzahl mal. Der aktuelle Z\u00e4hlerstand ist in der Schleife in der Variable count verf\u00fcgbar.  
bc.repeat_times=Mal 
bc.commands=Befehle 
bg.repeat=Zählschleife 
bg.repeat2.description=Wiederhole die Befehle genau eine bestimmter Anzahl mal. Der aktuelle Z\u00e4hlerstand ist in der Schleife in der Variable count verf\u00fcgbar.  
bg.repeat2=Zählschleife 
bc.from=Von
bc.to=Bis

bc.variable=Variable 
bg.variable_poly=Name der String-Variable (Text) 
bg.variable_digital.description=Binär-Variable kennt nur zwei Zustände 
bg.variable_number.description=Zahl-Variable (Ganze Zahl) 
bg.variable_digital=Name der Binär-Variable 
bg.variable_digital.description=Zugriff auf Binär-Variable 
bg.variable_number=Name der Zahl-Variable
bg.variable_number.description=Zugriff auf Zahl-Variable (Ganze Zahl) 
bg.variable_String=Name der String-Variable 
bg.variable_String.description=Zugriff auf String-Variable (Text) 
bg.variable_String_Payload=Payload 
bg.variable_String_Payload.description=Zugriff auf den Payload (Übertragene Daten des Kommunikationsprotokolls) 
bg.variable_number_LoRaPayload=LoRaWAN_Rx_Payload 
bg.variable_number_LoRaPayload.description=Lesezugriff auf den Payload des Kommunikationsprotokolls (als Ganze Zahl) 
bg.while=Solange 
bg.while.description=Solange der Test der Bedingung ein wahr liefert, werden die Befehle wiederholt 
bc.condition=Teste 
bg.if=Falls 
bg.ifelse=Falls/sonst 
bg.if.description=Führe die Befehle nur aus, falls der Test der Bedingung ein wahr ergibt 
bg.ifelse.description=Führe die Befehle im ersten Block nur aus, falls der Test der Bedingung ein wahr ergibt. Sonst führe den zweiten Block aus 
bc.test=teste 
bc.then=dann 
bg.ifelse=Falls/sonst 
bg.ifelse.description=Führe die Befehle im ersten Block nur aus, falls der "test" der Bedingung ein wahr ergibt. Sonst führe den zweiten Block aus 
bc.else=sonst 
bg.delay.description=Warte eine Anzahl "Millisekunden".\nNOTE: 1000 Millisekunden = 1 Sekunde 
bg.delay=Delay (warte) 
bg.delay_microseconds=Warte ein paar Mikrosekunden 
bc.milliseconds=ms 
bg.subroutine=Unterprogramm 
bg.subroutine-ref=Unterprogramm 
bg.subroutine.description=Erstellt ein neues Unterprogramm (Deklaration) 
bg.subroutine-ref.description=Unterprogramm aufrufen 
bg.sub_return=UnterprogrammReturn 
bg.sub_return.description=Unterprogramm mit Returnparameter  
bg.sub_return-ref=UnterprogrammReturn 
bg.sub_return-ref.description=Aufruf Unterprogramm mit Returnparameter 
bc.sub_return = Rückgabewert 
bc.sub_commands = Unterprogramm Befehle 
bg.greater=> 
bg.greater_equal=>\= 
bg.greater.description=Wahr, wenn die erste Zahl gr\u00f6\u00dfer ist als die zweite Zahl 
bg.greater_equal.description=Wahr, wenn die erste Zahl gr\u00f6\u00dfer als oder gleich gro\u00df ist wie die zweite Zahl 
bg.less=< 
bg.less_equal=<\= 
bg.less.description=Wahr, wenn die erste Zahl kleiner ist als die zweite Zahl 
bg.less_equal.description=Wahr, wenn die erste Zahl kleiner als oder gleich gro\u00df ist wie die zweite Zahl 
bg.equal.description=Wahr, wenn die erste Zahl gleich gro\u00df ist wie die zweite Zahl 
bg.equal_digital.description=Wahr, wenn die erste Zahl gleich gro\u00df ist wie die zweite Zahl 
bg.equal_poly.description=Wahr, wenn das erstes Zeichen identisch mit dem zweiten Zeichen 
bg.greater_equal=>\= 
bg.greater_equal.description=Wahr, wenn die erste Zahl gr\u00f6\u00dfer als oder gleich gro\u00df ist wie die zweite Zahl 
bg.less_equal=<\= 
bg.less_equal.description=Wahr, wenn die erste Zahl kleiner als oder gleich gro\u00df ist wie die zweite Zahl 
bg.not_equal_poly=\!\= 
bg.not_equal_digital=\!\= 
bg.not_equal=\!\= 
bg.not_equal.description=Wahr, wenn die erste Zahl nicht gleich gro\u00df ist wie die zweite Zahl 
bg.not_equal_digital.description=Wahr, wenn die erste Zahl nicht gleich gro\u00df ist wie die zweite Zahl 
bg.not_equal_poly.description=Wahr, wenn das erstes Zeichen nicht identisch mit dem zweiten Zeichen 
bg.and=und 
bg.and.description=Wahr, wenn beide beide Bedingungen erf\u00fcllt sind. 
bg.or=oder 
bg.or.description=Wahr, wenn eine oder beide beide Bedingungen erf\u00fcllt sind. 
bg.not_equal_poly=\!\= 
bg.not_equal_digital=\!\= 
bg.not=nicht 
bg.not_equal=\!\= 
bg.not_equal.description=Wahr, wenn die erste Zahl nicht gleich gro\u00df ist wie die zweite Zahl 
bg.not_equal_digital.description=Wahr, wenn die erste Zahl nicht gleich gro\u00df ist wie die zweite Zahl 
bg.not.description=Das Gegenteil von 
bg.not_equal_poly.description=Wahr, wenn das erstes Zeichen nicht identisch mit dem zweiten Zeichen 
bg.equal_string= == 
bg.equal_string.description=Wahr, wenn die beiden Texte identisch gleich sind 
bg.not_equal_string= != 
bg.not_equal_string.description=Wahr, wenn die beiden Texte nicht identisch sind 
bg.addition=+ 
bg.addition.description=Summe zweier Zahlen 
bg.subtraction=- 
bg.subtraction.description=Differenz zweier Zahlen 
bg.multiplication=x 
bg.multiplication.description=Produkt zweier Zahlen 
bg.division=\u00f7 
bg.division.description=Quotient zweier Zahlen 
bg.modulo=% 
bg.modulo.description=Der Ganzzahlrest ist der Rest der Division (ähnlich Modulo)
bg.abs=Betrag 
bg.abs.description=Betrag  
bg.round=Rundung 
bg.round.description=Rundung 
bc.decimals=Stellen
bc.decimals.description=Anzahl der Nachkommastellen
bg.pow=Potenz 
bg.pow.description=Potenzfunktion 

bc.base=Basis 
bc.base.description=Basis der Potenzfunktion

bc.exponent=Exponent
bc.exponent.description=Exponent der Potenzfunktion
 
bg.sqrt=Wurzel 
bg.sqrt.description=Quadratwurzel 

bg.sin=sin 
bg.sin.description=Sinusfunktion (rad) 
bg.cos=cos 
bg.cos.description=Cosinusfunktion (rad) 
bg.tan=tan 
bg.tan.description=Tangenzfunktion
bg.random=Zufallszahl 
bg.random.description=Generiert eine zuf\u00e4llige Zahl, die kleiner ist als die Zahl 
bc.max=max 
bg.max=Max 
bg.max.description=Maximum 
bg.millis=millis 
bg.number=1 
bg.number.description=Eine konstante Zahl 
bg.digital-high=HIGH (wahr) 
bg.digital-high.description=Binäre Konstante wahr, High-Potential 
bg.digital-low=LOW (falsch) 
bg.digital-low.description=Binäre Konstante falsch, Low-Potential 
#bg.true=wahr 
bg.true.description=Binäre Konstante wahr / HIGH 
#bg.false=falsch 
bg.false.description=Binäre Konstante falsch / LOW
bg.variable_number=Name Integer Variable
bg.variable_number.description=Zugriff auf Zahl-Variable (Integer, ganze Zahl)
bg.variable_number_double=Name Float Variable 
bg.variable_number_double.description=Zugriff auf Gleitkommazahl (Float)
bg.variable_digital=Name Boolean Variable  
bg.variable_digital.description=Zugriff auf binäre Variable (Boolean) 
bg.variable_string=Name String Variable (Text)  
bg.variable_string.description=Zugriff auf Text Variable 
bg.setter_predef_number=PREDEFINITION
bg.setter_predef_number.description=Erstellt eine Compiler Predefinition. Blöckchen sollte am Beginn des setup() stehen. #define PREDEFINITION value
bg.predef_number.description=Nutze eine per #define erklärte Compiler-Konstante
bg.predef_number=PREDEFINITION 

bg.setter_variable_number=Setze Zahl-Variable  
bg.setter_variable_number.description=Wertzuweisung einer Zahl-Variable 
bg.setter_variable_number_double=Setze Zahl-Variable (Float) 
bg.setter_variable_number_double.description=Wertzuweisung einer Zahl-Variable (Gleitpunktzahlen) 
bc.value=Wert 

bg.local_variable_number= Lokale Integer Variable 
bg.local_variable_number.description =Zugriff auf lokale Zahl-Variable (nur ganze Zahlen) 

bg.readArrayVarNum=Lese Array 
bg.readArrayVarNum.description=Lese einen Wert vom Datenfeld am angegebenen Index 
bg.setArrayVarNum=Schreibe Array 
bg.setArrayVarNum.description=Setze Wert im Datenfeld an der angegebenen Stelle
bg.matrixArrayDisplay=LED-Matrix Array 
bg.matrixArrayDisplay.description=Visualisierung eines Arrays auf der LED-Matrix
 
bg.setter_variable_digital=Setze Binär-Variable 
bg.setter_variable_digital.description=Wertzuweisung einer binären Variable 
bg.setter_variable_String=Setze Text-Variable 
bg.setter_variable_String.description=Wertzuweisung einer String-Variable (Text) 
bg.variable_String=Name der String-Variable 
bg.variable_String.description=Lesezugriff auf String-Variable. Dies ist der Variablenname, kein auszugebender Text 
bg.variable_String_Payload=MQTT_Rx_Payload 
bg.variable_String_Payload.description=Lesezugriff auf letzten MQTT Payload (String). Dieser enthält die unter dem Topic übertragene Information 
bg.serial_print=Serial print 
bg.serial_print.description=Sendet eine Nachricht \u00fcber die serielle Schnittstelle 
bg.serial_readString=Serial read 
bg.serial_readString.description=Liest eine Nachricht von der seriellen Schnittstelle 
bc.message=Message 
bg.message=Hallo Welt
bg.message.description=Ein konstanter Text (z.B. "Hallo Welt")
bc.ln=neue Zeile 
bg.glue_sn=verbinde 
bg.glue_sn.description=Adapter (typcast), wandelt Zahl zu einer Zeichenkette 
bg.glue_sb=verbinde 
bg.glue_sb.description=Adapter (typcast), wandelt binäre Werte zu einer Zeichenkette 
bg.glue_poly=verbinden 
bg.glue_poly.description=Adapter (typcast), wandelt Zeichen zu einer Zeichenkette
bg.cat_string=verbinde
bg.cat_string.description=Verbindet zwei Zeichenketten 
bg.cat_string3=verbinde
bg.cat_string3.description=Verbindet drei Zeichenketten 

bg.glue_nb=verbinde 
bg.glue_nb.description=Adapter (typecast), wandelt binäre Werte zu einer Zahl
bg.glue_ns=verbinde 
bg.glue_ns.description=Adapter (typecast), wandelt Zeichenkette zu einer Zahl 


bg.pin-mode-pullup=Pullup Widerstand für digitalRead 
bg.pin-mode-pullup.description=Schaltet ggf. einen internen Pullup-Widerstand  
bg.pin-read-digital=digitalRead (digitaler Eingang) 
bg.pin-read-digital.description=Liest den Digitalwert von einem GPIO-Pin 
bg.button_press =Encoder (button) 
bg.button_press.description =Einlesen des Encoder-Knopfes (drücken des Knopfes) 
bg.button_rot   =Encoder (turn) 
bg.button_rot.description   =Einlesen der Drehbewegung des Encoder-Knopfes (drehen)
bg.button_rot_minmax=Encoder (bounds) 
bg.button_rot_minmax.description=Begrenzt den Wertebereich des Drehencoders  
bg.pin-read-analog=analogRead (analoger Eingang)
bg.pin-read-analog.description=Lies den Analogwert vom angegebenen pin 
bg.GetBMETemp=Temperatur 
bg.GetBMETemp.description=Messwert für Temperatur 
bg.GetBMEPress=Druck
bg.GetBMEPress.description=Messwert für Luftdruck vom Bosch-Sensor
bg.GetBMEHum=Luftfeuchte
bg.GetBMEHum.description=Messwert Luftfeuchte vom Bosch-Sensor

bg.GetBME=Umwelt BME280 
bg.GetBME.description=Umweltinformation vom Bosch BME 280
bg.GetBME_Adr=Umwelt (T,F,p) BME280
bg.GetBME_Adr.description=Umweltinformation vom Bosch BME 280. Der Baustein funktioniert auch für den BMP280 (ohne Feuchte). Typische I2C-Adressen sind 0x76 oder 0x77
bc.BMEVector=Sensor 
bg.BMEVectorPress=Luftdruck 
bg.BMEVectorTemp=Temperatur 
bg.BMEVectorHum=Luftfeuchte 

bg.GetBME680=Temp, Feuchte, Druck, VOC BME680
bg.GetBME680.description=Umweltinformation vom Bosch BME 680. Arbeitet direkt, d.h. ohne BSEC-Algotithmus. <offset> korrigiert den Messwert manuell, indem der offset zum Messwert dazu addiert wird. <gasheat> bestimmt die Heiztemperatur bei der Gasmessung (in Grad C) 
bg.GetBME680offset=Umwelt (T,F,p,VOC) BME680
bg.GetBME680offset.description=Umweltinformation vom Bosch BME 680. Arbeitet direkt, d.h. ohne BSEC-Algorithmus
bc.BME680Vector=Sensor 
bg.BME680VectorPress=Luftdruck 
bg.BME680VectorTemp=Temperatur 
bg.BME680VectorHum=Luftfeuchte 
bg.BME680VectorGas=Gassensor 
bg.BME680VectorIAQ=IAQ 

bg.GetBSEC=Umwelt (T,F,p,VOC) BSEC2 
bg.GetBSEC.description=Umweltinformation vom Bosch BME 680, intelligente Korrektur durch BSEC-Algorithmus  
bg.BSECVectorIAQ=IAQ
bg.BSECVectorIAQAccuracy=IAQ Accuracy
bg.BSECVectorTemp=Temperatur
bg.BSECVectorHum=Feuchte (corr.)
bg.BSECVectorPress=Luftdruck
bg.BSECVectorCO2=CO2 (equivalent)
bg.BSECVectorVOC=VOC (breath)
bg.BSECVectorHumRaw=Feuchte (raw)
bg.BSECVectorTempRaw=Temp (raw)
bg.BSECVectorGasRaw=Gas

bg.DosisIntegral=Integral
bg.DosisIntegral.description=Berechnet das Integral einer Messgröße 
bg.EMAsmooth=Exponentielle Glättung
bg.EMAsmooth.description=Glättet das Signal mittels exponentiellem Mittelwert (exponential moving average). Zeitkonstante legt die Dynamik fest 

bg.MEANsmooth=Mittelwert
bg.MEANsmooth.description=Führt mehrere Abtastungen durch und mittelt diese. Wartezeit zwischen den Abtastungen entsprechend der Sensordynamik. 

bg.GetSCD40=CO2 Sensirion SCD4x 
bg.GetSCD40.description=Umweltinformation vom Sensirion SCD40
bg.CalSCD40=CO2 Kalibriere SCD4x
bg.CalSCD40.description=Kalibriert den Sensor auf Frischluft = 400 ppm. Dazu ist vorher längere Zeit unter Frischluftbedingungen nötig
bg.GetSCD30=CO2 Sensirion SCD30
bg.CalSCD30=CO2 Kalibriere SCD30 
bg.CalSCD30.description=Kalibriert den Sensor auf Frischluft = 400 ppm. Dazu ist vorher längere Zeit unter Frischluftbedingungen nötig
bg.GetSCD30.description=Umweltinformation vom Sensirion SCD30
bc.SCD30Vector=Sensor 
bg.SCD30VectorCO2=CO2 
bg.SCD30VectorTemp=Temperatur 
bg.SCD30VectorHum=Luftfeuchte 

bg.GetGPS=GPS Serial MTK3339
bg.GetGPS.description=Ermittle GPS Koordinaten. Updatefix holt neue Datensatz vom Sensor, die anderen Parameter lesen den Datensatz. Nur dann sind die Daten konsistent.
bc.GPSVector=Data 
bg.GPSVectorUpdate=SatUpdateFix 
bg.GPSVectorLat=Breitengrad 
bg.GPSVectorLong=Laengengrad
bg.GPSVectorAlt=Hoehe
bg.GPSVectorHdop=Hdop

bg.GetBNO=Lage Bosch BNO  
bg.GetBNO.description=Liefert die Orientierung im Raum 
bc.BNOVector=Sensor 
bc.BNOVector.description=Sensortyp 
bg.BNOVectorAcc=Beschleunigung 
bg.BNOVectorOrient=Orientierung 
bg.BNOVectorGyro=Gyroscope 
bg.BNOVectorMagnet=Magnetfeld 
bc.BNODim=Achse 
bc.BNODim.description=Achseninformation 
bg.BNODimX=X-Achse 
bg.BNODimY=Y-Achse 
bg.BNODimZ=Z-Achse 

bg.OLED_DispArray =OLED Plot Zeitreihe
bg.OLED_DispArray.description = Zeitreihe auf dem OLED-Display zeichnen. Der Wert <value> definiert den Messert, <min> und <max> sorgen für die Achsenskalierung. (Quelle für Hardware: https://www.adafruit.com/product/4650)

bg.Feather7Seg =7-Segment-Display
bg.Feather7Seg.description = Ausgabe auf 7-Segment-Display (https://learn.adafruit.com/adafruit-7-segment-led-featherwings/overview)
bc.7Seg=Ausgabe
bc.7Seg.description=Ausgabe 7-Segment-Anzeige

bg.ADPS9960Get=Farbe, Geste, Abstand APDS9960 
bg.ADPS9960Get.description=Farb-, Abstands- und Gestenerkennung 
bg.ADPS9960Cal=Farbe Weissabgleich APDS9960 
bg.ADPS9960Cal.description=Kalibiere die Farberkennung (weißes Papier vor den Sensor halten) 
bc.ADPS9960Vector=Sensor 
bc.ADPS9960Vector.description=Sensortyp 
bg.ADPS9960Gest=Gesten 
bg.ADPS9960Prox=Abstand 
bg.ADPS9960Ambi=Licht (Lux)
bg.ADPS9960Red=Rot 
bg.ADPS9960Green=Gruen 
bg.ADPS9960Blue=Blau 

bg.NFCRead=NFC-Reader 
bg.NFCRead.description=Lese NFC-Tags (Mifare)
bc.NFCVector=Type 
bc.NFCVector.description=Informationstyp
bg.NFCVectorHash=Hash ID 
bg.NFCVectorID=ID 
bg.NFCVectorPay=Payload
bg.NFCVectorHash.description=Hash ID 
bg.NFCVectorID.description=ID 
bg.NFCVectorPay.description=Payload

bg.NFCWrite=NFC-Write 
bg.NFCWrite.description=Schreibe NFC-Payload auf das Tag (Mifare)
bc.NFCmessage=Payload 
bc.NFCmessage.description=Payload Text 
bg.NFCmessage=Payload
bg.NFCmessage.description=Payload Text 

bg.GetMGas=Multigas Sensor MiCS-6814 
bg.GetMGas.description=Multisensor Gasmessung in ppm
bc.MGasVector=sensor 
bc.MGasVector.description=gas sensor (ppm) 
bg.MGasVectNH3=NH3 (ppm)
bg.MGasVectCO=CO (ppm)
bg.MGasVectNO2=NO2 (ppm)
bg.MGasVectC3H8=C3H8 (ppm) 
bg.MGasVectC4H10=C4H10 (ppm)
bg.MGasVectCH4=CH4 (ppm)
bg.MGasVectH2=H2 (ppm)
bg.MGasVectC2H5OH=C2H5OH (ppm)
bg.MGasVectRawR00=Kanal0 R0
bg.MGasVectRawRS0=Kanal0 Rs
bg.MGasVectRawR01=Kanal1 R0
bg.MGasVectRawRS1=Kanal1 Rs
bg.MGasVectRawR02=Kanal2 R0
bg.MGasVectRawRS2=Kanal2 Rs

bg.GetMaxbotix=Abstand Maxbotix Ultraschall
bg.GetMaxbotix.description=Ultrasonic Distance

bg.GetMaxbotix2=Abstand Maxbotix Ultraschall
bg.GetMaxbotix2.description=Abstandsmessung mit Maxbotix Sensoren (Ultrasonic Distance)

bg.MapC=Mapping 
bg.MapC.description=Ermöglicht die Umrechnung von Werten auf einen anderen Bereich. Es wird von <in> auf <out> gemapped. Nur Interpolation, keine Extrapolation, Werte werden begrenzt  


bg.medianfilter=Medianfilter 
bg.medianfilter.description=Medianwerte ermitteln, macht die Messung robust gegen Ausreisser. Führt drei Messungen des an <value> angeschlossenen Sensors durch. Zwischen den Messungen gibt es ggf. eine mit <pause> zu definierende Wartezeit (z.B. lightsleep). Falls die erfassten Messwerte außerhalb des durch <valueMin> und <valueMax> begrenzten Bereichs liegen, wird die Messung mehrfach wiederholt. Anschließend werden die Messungen sortiert und der mittlere Wert (Median ist nicht der Mittelwert) zurückgeliefert. 
bg.GetDFRobotUS=Abstand DFRobot Ultraschall
bg.GetDFRobotUS.description=Ultrasonic Distance (https://wiki.dfrobot.com/A01NYUB%20Waterproof%20Ultrasonic%20Sensor%20SKU_SEN0313#target_7)

bg.GetDustHM330=Feinstaub HM330
bg.GetDustHM330.description=Feinstaubsensor HM330
bg.GetDustHoney=Feinstaub Honeywell
bg.GetDustHoney.description=Feinstaubsensor Honeywell
bc.DustHoneyVector=Groesse
bc.DustHoneyVector.description=Partikelgroesse
bg.DustHoneyVect25 = PM 2.5 (µg/m3)
bg.DustHoneyVect10 = PM 10  (µg/m3)


bg.GetLightBH=Licht BH1750
bg.GetLightBH.description=Lichtsensor BH1750
bg.GetLightTSLnew=Licht TSL2561
bg.GetLightTSLnew.description=Lichtsensor TSL2561

#bc.LightTSLVector=Spektrum
#bc.LightTSLVector.description=Lichtspektrum Detektor
bg.LightTSLVectLux =Beleuchtung (lux)
bg.LightTSLVectVis =Breitband (vis+ir)
bg.LightTSLVectIR = Infrarot (ir)

bg.GetHX711=Waage HX711, Messwert
bg.GetHX711.description=Messwert in Units, vorher kalibrieren

bg.TaraHX711=Waage HX711, Tara
bg.TaraHX711.description=Setzt Tara, bestimmt den Offset
bg.CalHX711=Waage HX711, Kalibrieren
bg.CalHX711.description=Kalibriert in Units (z.B. kg, g oder Stück). Liefert die Kalibriersteigung. Diese kann später per Blöckchen gesetzt werden und vermeidet so das Kalibrieren bei jedem Neustart

bg.GetScaleHX711=Waage HX711, Kalibriersteigung lesen
bg.GetScaleHX711.description=Kalibriersteigung nach erfolgter Kalibrierung auslesen
bg.SetScaleHX711=Waage HX711, Kalibriersteigung setzen
bg.SetScaleHX711.description=Kalibriersteigung setzen, ersetzt Neukalibrierung bei jedem Neustart



bg.askSMARD=SMARD Stromdaten
bg.askSMARD.description= Dieser Block liefert eine Schätzung für den Anteil erneuerbarer Energieen ind Deutschland. Grundlage ist die SMARD Datenbank der Bundesnetzagentur. Die Daten werden zyklisch abgefragt, der Anteil berechnet und online bereitgestellt. Studienarbeit am Umwelt-Campus (https://www.umwelt-campus.de/iot-werkstatt/tutorials/klimaschutz-iot-stromboerse-und-co2)

bg.DIYSpectro=Spektrometer TSL
bg.DIYSpectro.description=Absorptionsspektrometer mit TSL2561, gemeinsam mit HAW Hamburg (https://www.haw-hamburg.de/hochschule/life-sciences/forschung/projekte-schullabor/schullabor-mobile-analytik/) 
bg.DIYSpectroBH=Spektrometer BH
bg.DIYSpectroBH.description=Absorptionsspektrometer mit BH1750, gemeinsam mit HAW Hamburg (https://www.haw-hamburg.de/hochschule/life-sciences/forschung/projekte-schullabor/schullabor-mobile-analytik/) 
bg.DIYSpectroVectOctiW  =Weiss Octopus
bg.DIYSpectroVectOctiRGB=RGB   Octopus
bg.DIYSpectroVectD1W    =Mono  Pin 15

bg.absHum=Abs. Feuchte
bg.absHum.description=Berechnet die absolute Luftfeuchte. Grundlage: Temperatur und aktuelle relative Feuchte

bg.SX1509_read = Port Expander SX1509 
bg.SX1509_read.description = Erweitert den I/O-Bereich um digitale Eingänge
bg.pin-read-digital_SX = SX1509 Digital Input
bg.pin-read-digital_SX.description=Der SX1509 erweitert den IO-Bereich um digitale Eingänge
bg.SX1509_write = Port Expander SX1509
bg.SX1509_write.description = Erweitert den I/O-Bereich um digitale Ausgänge
bg.pin-write-digital_SX = SX1509 Digital Output
bg.pin-write-digital_SX.description = Port Expander Digital Output

bg.MPR121_read = Touch Sensor MPR121
bg.MPR121_read.description = Der MPR121 erweitert den I/O-Bereich um einen Touch Sensor
bg.pin-read-digital_MP = Touch Sensor
bg.pin-read-digital_MP.description = Touch Sensor Input

bg.feather_motor = Feather DC-motor 
bg.feather_motor.description = Anteuerung eines Gleichstrommotors mit dem Feather Motor Shield (Geschwindigkeit positiv und negativ)

bg.feather_stepmotor = Feather Stepper 
bg.feather_stepmotor.description = Ansteuerung eines Schrittmotors mit dem Feather Motorshield (Anzahl der Schritte positiv und negativ)

bg.pin-write-servo = Servo Ansteuerung 
bg.pin-write-servo.description = Drehwinkel in Grad

bg.iot_WS2812=Neopixel WS2812 
bg.iot_WS2812.description=Externe Farb-LED (Strombedarf beachten!, jedes Neopixel pro Farbe 20 mA, summiert sich).  
#bg.iot_WS2812Ring=Neopixel WS2812 Kreis
#bg.iot_WS2812Ring.description=Externe Farb-LED (Strombedarf beachten!, jedes Neopixel pro Farbe 20 mA, summiert sich). 
bg.iot_WS2812Ring_c=Neopixel WS2812 Kreis
bg.iot_WS2812Ring_c.description=Externe Farb-LED (Strombedarf beachten!, jedes Neopixel pro Farbe 20 mA, summiert sich). 


bg.LIDAR_TFmini_read =Abstand LIDAR TFmini
bg.LIDAR_TFmini_read.description = Das Blöckchen nutzt UART 

bg.pin-read-analog121 = ADC I2C Grove
bg.pin-read-analog121.description = Erweiterung der I/O Fähigkeiten. Lese Analog-Wert via I2C (https://wiki.seeedstudio.com/Grove-I2C_ADC/)

bg.GetMMA7660=3-Axis Beschleunigung MMA7660 
bg.GetMMA7660.description=Beschleunigung in 3 Achsen per I2C 


bg.pin-write-digital=digitalWrite 
bg.pin-write-digital.description=Digitaler Ausgang für GPIO-Pin festlegen

bg.pin-write-digitalLED=LED 
bg.pin-write-digitalLED.description=Digitaler Ausgang, Ansteuerung der internen LED 
 
bc.pin_number=pin 
bg.pin-write-analog=analogWrite 
bg.pin-write-analog.description=Pulsweitenmodulation (PWM) zur Ansteuerung von digitalen Aktoren (Grehzahl über H-Brücke bei Motoren, Dimmung bei LED)  
bg.iot_neopixel=Neopixel 
bg.iot_neopixel.description=Ansteuerung der internen RGB-Neopixel. Es gibt ein einfacheres Blöckchen mit den Grundfarben 
bg.iot_neopixel_light=Neopixel 
bg.iot_neopixel_light.description=Ansteuerung der internen RGB-Neopixel. Es gibt ein weiteres Blöckchen mit kontinuierlicher RGB Farbauswahl
bc.neowahl=Ort 
bc.neowahl.description=Position (Links/Rechts) 
bc.red=Rot 
bc.green=Gruen 
bc.blue=Blau 
bc.NEOVector=Farbe 
bg.NEOVectorRed=Rot 
bg.NEOVectorGreen=Grün 
bg.NEOVectorYellow=Gelb 
bg.NEOVectorBlue=Blau 
bg.NEOVectorOff=Aus 
bg.NEOVectorWhite=Weiss 
bg.neo-links=Links 
bg.neo-links.description=Links 
bg.neo-rechts=Rechts 
bg.neo-rechts.description=Rechts 
bg.iot_neowing=Neopixel Wing 
bg.iot_neowing.description=Farbansteuerung des Feather-NeopixelWing (https://www.adafruit.com/product/2945)
bg.iot_matrixwing=LED-Matrix 
bg.iot_matrixwing.description=Ausgabe auf der Charlyplex LED-Matrix (https://www.adafruit.com/product/3138) 
bc.IoTmessage=Text 
bc.IoTmessage.description=Text mit Andockstelle zum Anfügen weiterer Blöckchen 
bg.IoTmessage=Text (cat) 
bg.IoTmessage.description=Text mit Andockstelle zum Anfügen weiterer Blöckchen 
bg.connectWLANAP=WLAN 
bg.connectWLANAP.description=Verbindet uns mit einem bestehenden WLAN AccessPoint 
bg.WiFiMan=WiFi Manager 
bg.WiFiMan.description=Verbindet nit dem letzten bekannten WLAN AccessPoint. Falls dieser nicht verfügbar, wird ein eigener AP geöffnet. Die SSID und das Passwort dafür wird hier definiert. Die eigentlichen WLAN Zugangsdaten werden dann mittels Handy in diesem AP definiert. 
    
bc.ssid=Netzname 
bg.ssid=Netzname 
bg.ssid.description=WLAN Netzname

bg.connectWLANAPTO=WLAN mit Timeout 
bg.connectWLANAPTO.description=Versucht eine Verbindung zum WLAN AccessPoint. Gibt es nach Ablauf des Timeouts keine Verbindung, wird false zurückgegeben. Andernfalls true 
bc.timeout=Timeout (s) 
bc.ssid.description=Timeout bei Anmeldung 
 
bc.pass=Passwort 
bg.passwort=Passwort 
bg.passwort.description=WLAN Passwort 
bg.buildWLANAP=AccessPoint 
bg.buildWLANAP.description=Spannt einen eigenen AccessPoint (analog zum Hotspot) auf.Sinnvoll in Verbindung mit dem HTTP-Server, OTA oder Shelly-Steckdosen). IP Adresse 192.168.4.1 
bg.connectGPRS=Mobilfunk-Modem 
bg.connectGPRS.description=Verbindet mit einem Mobilfunknetz 
bc.GPRSapn=APN 
bg.GPRSapn=Mobilfunk APN 
bg.GPRSapn.description=Mobilfunk APN 
bc.GPRSuser=User 
bg.GPRSuser=User 
bg.GPRSuser.description=User 
bc.GPRSpass=Passwort 
bg.GPRSpass=Passwort 
bg.GPRSpass.description=Passwort 
bg.snifferWLAN=PaxCounter 
bg.snifferWLAN.description=Zählt WiFi-Clients (Smartphones) in der Umgebung (MAC-Adressen auswerten). 
bc.snifferChannel=Channel 
bc.snifferMac=MAC Adresse 
bc.snifferRSSI =Feldstärke
bc.snifferDisplay=Anzeige
bg.snifferChannel.description=Zu überwachender WLAN Kanal. Ohne Angabe werden alle Kanäle gescannt
bg.snifferMac.description=Optional Angabe der MAC Adresse, die gesucht wird (Achtung nur bei eigenem Gerät erlaubt, Datenschutz/Privatsphäre beachten)
bg.snifferRSSI.description =Über die Feldstärke lässt sich die Entfernung (Überwachungsradius) regulieren
bg.snifferDisplay.description=Ausgabe der ersten Bytes der MAC Adresse. Es werden keine vollständigen Adressen gespeichert, nur Hash - Werte um Adressen zu zählen

bg.packetsWLAN=PacketCounter 
bg.packetsWLAN.description=Zählt alle Pakete auf dem WiFi Kanal (Auslastung)

bg.scanSSIDWLAN=SSID Beobachter
bg.scanSSIDWLAN.description=Anzeige von SSID probe requests (Datenschutz beachten)

bg.mDNS=Domain Name Service mDNS
bg.mDNS.description=Domain Name Service (.local)

 
bg.ownMessageServer=Web-Server einfach 
bg.ownMessageServer.description=HTTP-Server zur Messdatenausgabe / Matrixanzeige. IP Adresse bei eigenem Accesspoint 192.168.4.1, sonst per DHCP zugeteilt

bg.ownMessageServer_CO2=Web-Server CO2 
bg.ownMessageServer_CO2.description=HTTP-Server für eine CO2-Ampel (oder andere Messwerte). IP Adresse bei eigenem Accesspoint 192.168.4.1, sonst per DHCP zugeteilt

 
bc.homepageTitle=Titel 
bg.homepageTitle=Titelzeile 
bg.homepageTitle.description=Titelzeile der Hompage 
bc.hompageSensorwahl=Anzeige 
bg.hompageMitSensor=Mit Sensoren 
bg.hompageOhneSensor=Ohne Sensoren 

bg.sendThingspeak=Thingspeak, send 
bg.sendThingspeak.description=Übermittelt Messwerte an die Thingspeak Cloud. Der <API-Key> wird nach Anmeldung beim Thingspeak Server über cut&paste übernommen. Für Free-accounts gilt ein Update-Zyklus von mindestens 15 s 
bc.host=Server 
bg.host=Servername 
bg.host.description=Servername 
bc.apikey=API-Key 
bg.apikey=API-Key 
bg.apikey.description=geheimer eigener API-Key 
bc.thing1=Feld 1 
bg.thing1=Messwert 
bg.thing1.description=Messwert Feld 1 
bc.thing2=Feld 2 
bg.thing2=Messwert 
bg.thing2.description=Messwert Feld 2 
bc.thing3=Feld 3 
bg.thing3=Messwert 
bg.thing3.description=Messwert Feld 3 
bc.thing4=Feld 4 
bg.thing4=Messwert 
bg.thing4.description=Messwert Feld 4 
bc.thing5=Feld 5 
bg.thing5=Messwert 
bg.thing5.description=Messwert Feld 5 
bc.thing6=Feld 6 
bg.thing6=Messwert 
bg.thing6.description=Messwert Feld 6 
bc.thing7=Feld 7 
bg.thing7=Messwert 
bg.thing7.description=Messwert Feld 7 
bc.thing8=Feld 8 
bg.thing8=Messwert 
bg.thing8.description=Messwert Feld 8 

bg.askThingspeak=Thingspeak, read 
bg.askThingspeak.description=Abfrage eines aktuellen Messwertes im Thingspeak Kanal. Der <Kanal> ist die Channel-ID beim Server (thingspeak.com). Steht dort z.B. in der URL bei der Visualisierung der Daten. Der Channel muss public sein, d.h. für alle sichtbar. 
bc.channel=Kanal 
bc.channel.description=Channel ID im Thingspeak 
bc.feld=Feldindex 
bc.feld.description=Index Field 

#bg.sendHeruko=heruko 
#bg.sendHeruko.description=sends values to heruko 

bg.sendThingsboard=Thingsboard, send  
bg.sendThingsboard.description=Sendet JSON Daten an die thingsboard cloud. Es gibt ein weiteres Blöckchen zur Erzeugung eines JWT Tokens zur Authorisierung 

bg.askThingsboard=Thingsboard, read 
bg.askThingsboard.description=Lädt JSON Daten aus der thingsboard cloud. Anschließend mit dem JSON Blöckchen auswerten. 


bg.sendSensebox=OpenSenseMap.org
bg.sendSensebox.description = Sende Daten an die Geo-Cloud von OpenSenseMap.org.Die <Box-ID> und <Sensor-ID> wird nach Anmeldung am Server vergeben. 

bg.sendLuftdaten=Sensor.community
bg.sendLuftdaten.description = Sende Daten an die Geo-Cloud von Sensor.community. Die <Sensor-ID> wird nach Anmeldung am Server vergeben.

bg.sendIFTTT2=If This Then That (IFTTT.com)
bg.sendIFTTT2.description=Auslösen eines If This Then That Ereignisses 
bc.trigger_logic=Logic 
bc.trigger=Trigger 
bg.trigger=Trigger 
bg.trigger.description=Name des IFTTT Triggers 
bc.key=Key 
bg.key=Key 
bg.key.description=IFTTT Key 

bg.sendHTTPGet=http GET 
bg.sendHTTPGet.description=REST Protokoll, HTTP-GET. Es gibt ein eigenes JSON-Blöckchen zur Auswertung der Antwort 

bg.LEDShelly=Shelly LED
bg.LEDShelly.description=Ändert die Beleuchtung des farbigen Rings am Shelly Plus (soweit nicht intern übersteuert)
bg.sendShelly=Shelly Switch
bg.sendShelly.description=Schaltet die Shelly Steckdose Gen 1 und 2 (https://kb.shelly.cloud/knowledge-base/shelly-plus-plug-s-1)
#bg.getShelly=Shelly Meter
#bg.getShelly.description=power meter
bg.getShelly2=Shelly Meter
bg.getShelly2.description=Leistungs und Energiemessung mit dem Shelly Plug. Ein Shelly Plug der ersten Generation kann nur Leistung messen
bc.ShellyVector=Val
bc.ShellyVector.description=measurement
bg.ShellyVectorPower=Leistung [W] 
bg.ShellyVectorPower.description=power meter
bg.ShellyVectorTotal=Energie [Wh] 
bg.ShellyVectorTotal.description=power meter
bg.ShellyVectorTemp=Temperature [C] 
bg.ShellyVectorTotal.description=power meter
bc.ShellyVectorGen=Generation 
bc.ShellyVectorGen.description=power meter

bg.ShellyVectorGen1=Shelly (Gen. 1) 
bg.ShellyVectorGen1.description=Erste Version (geriffeltes Gehäuse)

bg.ShellyVectorGen2=ShellyPlus (Gen. 2)
bg.ShellyVectorGen2.description=Zweite Eneration (glattes Gehäuse)
bg.sendInfluxDB=InfluxDB send  
bg.sendInfluxDB.description=Sende Daten an die Datenbank 
bg.createInfluxDB=InfluxDB create 
bg.createInfluxDB.description=Erstelle Zugangsdaten  

bg.createEDGE=EDGE IMPULSE create 
bg.createEDGE.description=Erstellt Informationen zur Datenbasis 

bg.sampleEDGE=EDGE IMPULSE sample 
bg.sampleEDGE.description=Sammelt Daten im Datenfeld (max. 50 Messzeitpunkte a maximal 4 Sensoren) 

bg.sendEDGE=EDGE IMPULSE send 
bg.sendEDGE.description=Sende die Daten zur Bearbeitung in die Cloud (https://edgeimpulse.com/) 

bg.classifyEDGE=EDGE IMPULSE inference 
bg.classifyEDGE.description=Klassifikation / Regression über eine Bibliothek von EDGE_IMPULSE. Nach Lösung der KI-Aufgabe in der Cloud den Algorithmus in Form der Bibliothek von dort herunterladen. (https://edgeimpulse.com/) 

bg.classifyEDGEc =classification
bg.classifyEDGEr =regression


bg.sampleClass=EDGE sample
bg.sampleClass.description=Erfasst Trainingsdaten (Lernstichprobe) für den Nächsten-Nachbar-Klassifikator oder die Regression. Maximal 50 Datenpunkte a maximal 3 Sensoren. Um bei der Regression eine automatische Modellentscheidung zur ermöglichen, wird zwischen Kalibier- und Validierdaten unterschieden 

bg.detClass=EDGE classify NN
bg.detClass.description=Klassifiziere die Daten anhand des trainierten NN-Klassifikators aus der Lernstichprobe (Kalibrierdaten)


bg.AIDatatypVal =Validierdaten
bg.AIDatatypCal =Kalibrierdaten

bg.AIcaliRegModel=EDGE calibrate
bg.AIcaliRegModel.description=Bestimme die Modellparameter der ausgewählten Regressionsmodelle. Nutzt die Kalibrierdaten. 

bg.AIselectRegModel=EDGE select model
bg.AIselectRegModel.description=Wählt auf der Grundlage der gewählten Daten das beste Regressionsmodell aus

bg.AIcalcRegModel=EDGE apply
bg.AIcalcRegModel.description=Wendet das trainierte Regressionsmodell an

bg.AIcaliRegModel=EDGE calibrate
bg.AIcaliRegModel.description=Bestimme die Modellparameter der ausgewählten Regressionsmodelle. Nutzt die Kalibrierdaten. 

bg.AIModeltypAuto=all/auto
bg.AIModeltypLin =linear
bg.AIModeltypQuad=quadratic
bg.AIModeltypCub =cubic
bg.AIModeltypExp =exponential

bg.text=Text 
bc.text=Text 

bg.URI=URI 
bc.URI=URI 
bg.URI.description=Kommando 
bg.port=Port 
bc.port=Port 
bg.port.description=Port Nummer (80, 8080) 

bg.sendBlynk=Blynk-VirtualWrite 
bg.sendBlynk.description=Übermittelt Werte an Blynk-Cloud (https://blynk.cloud) 

bg.readBlynk=Blynk-VirtualRead 
bg.readBlynk.description=Übermittelt Werte von Blynk-Cloud (https://blynk.cloud)

bg.payloadStrBlynk=Payload Text
bg.payloadStrBlynk.description=Übertragende Payload-Daten (interpretiert als Text)
bg.payloadIntBlynk=Payload Integer
bg.payloadIntBlynk.description=Übertragene Payload-Daten (interpretiert als Integer)
bg.payloadFloatBlynk=Payload Float
bg.payloadFloatBlynk.description=Übertragene Payload-Daten (interpretiert als Float)

bg.connectBlynk=Blynk-Cloud 
bg.connectBlynk.description=Konfiguration Blynk (https://blynk.cloud)


bg.mqttconnect=mqtt 
bg.mqttconnect.description=connect, Verbindung mit MQTT-Broker 
bc.mqttbroker=Broker 
bg.mqttbroker.description=URL MQTT-Broker 
bg.mqttbroker=mqtt broker 
bc.mqttclient=Client 
bg.mqttclient=Client 
bg.mqttclient.description=Name des MQTT-Clients 
bg.mqttclient=mqtt client 
bg.mqttclient.description=Name des eigenen MQTT-Clients 
bg.mqttpublish=mqtt publish 
bg.mqttpublish.description=Nachricht an den Broker senden. Das <Retained>-Flag sorgt dafür, dass die letzte gesendete Nachricht eines Topics auf dem Broker gespeichert bleibt und sofort an neue Abonnenten gesendet wird, sobald sie sich anmelden.  
bc.mqtttopic=Topic 
bg.mqtttopic=Topic 
bg.mqtttopic.description=mqtt topic, Bezeichnung der Nachricht 
bg.mqttpayload=mqtt payload 
bg.mqttpayload.description=Inhalt der Nachricht (Payload) 
bg.mqttsubscribe=mqtt subscribe 
bg.mqttsubscribe.description=Subscribe, abonniert Nachricht beim Broker. Führt <callback> aus, falls neue Nachrichten eintreffen. <QoS>: (Quality of Service) definiert die Zuverlässigkeit der Nachrichtenübertragung und bestimmt, ob Nachrichten einmal (QoS 0), mindestens einmal (QoS 1) oder genau einmal (QoS 2) zugestellt werden. 
bc.mqttpayload=Payload 
bc.mqttcallback=callback 
bg.mqttcallback=callback 
bg.mqttcallback.description=Subscribe Callback function. Wird aufgerufen, wenn es eine neue Nachricht gibt. Bitte keine blockierenden Befehle verwenden.  

bg.sendTTN_RFM95_ota=TTN (OTAA) 
bg.sendTTN_RFM95_ota.description=Übermittelt Messwerte an TTN, verwendet dabei das otaa-Protokoll. Die Keys werden bei der Device Registration im TTN-Netz erstellt und per Cut&Paste übernommen. <Port> und <Felder> sind frei zu wählen. Hardware RFM95 (FeatherWing mit SX1276). Weitere Info: https://id.thethingsnetwork.org 

bc.TTN_DEVEUI=Dev EUI 
bg.TTN_DEVEUI=Dev EUI 
bg.TTN_DEVEUI.description=TTN Device EUI (8 Byte) 
bc.TTN_APPEUI=App EUI 
bg.TTN_APPEUI=App EUI 
bg.TTN_APPEUI.description=TTN Application EUI (8 Byte) 
bc.TTN_APPKEY=App Key 
bg.TTN_APPKEY=App Key 
bg.TTN_APPKEY.description=TTN Application Key  (16 Byte) 
bc.TTN_PORT=Port 
bg.TTN_PORT=Port 
bg.TTN_PORT.description=TTN Message Port 
bg.sendTTN_RFM95_abp=TTN (ABP) 
bg.sendTTN_RFM95_abp.description=Übermittelt Messwerte an TTN, verwendet dabei das abp-Protokoll. Die Keys werden bei der Device Registration im TTN-Netz erstellt und per Cut&Paste übernommen. <Port> und <Felder> sind frei zu wählen. Hardware RFM95 (FeatherWing mit SX1276). Weitere Info: https://id.thethingsnetwork.org 
bc.TTN_DEVADD=Dev Addr 
bg.TTN_DEVADD=Dev Addr 
bg.TTN_DEVADD.description=TTN Device Adress (4 Byte) 
bc.TTN_NETSKEY=NetS Key 
bg.TTN_NETSKEY=NetS Key 
bg.TTN_NETSKEY.description=TTN Network Session Key (16 Byte) 
bc.TTN_APPSKEY=AppS Key 
bg.TTN_APPSKEY=AppS Key 
bg.TTN_APPSKEY.description=TTN Application Session Key  (16 Byte) 

bg.NTP= Uhrzeit, Abfrage Network Time Protokoll
bg.NTP.description = Uhrzeit Service, stellt die intere Uhr über Abruf von einem NTP-Server 

bg.NTPctime= Uhrzeit als Text
bg.NTPctime.description = Uhrzeit als Text 

bg.NTPunix= Uhrzeit Now (Unix-Time)
bg.NTPunix.description = Uhrzeit als Sekunden seit 1970 


bg.sleep=deep Sleep 8266 
bg.sleep.description=Tiefschlaf für <ms> Millisekunden, danach Neustart mit (true) oder ohne (false) WLAN aktiv. Alle GPIOs verlieren ihren elektischen Pegel. 
bg.sleepRF=WLAN RF 
bg.sleepRF.description=Aufwachen mit (true) oder ohne (false) WLAN 
bc.sleepRF=WLAN RF 
bg.sleepRF=WLAN RF 
bg.sleepRF.description=Aufwachen mit (true) oder ohne (false) WLAN



bg.sleep32=deep sleep 32 
bg.sleep32.description=Tiefschlaf für <ms> Millisekunden. Achtung: GPIO Ausgänge floaten. Um diese zu fixieren gibt es ein gesondertes Blöckchen (RTC_GPIO). Nach Ablauf der <ms> gibt es einen Deepsleep-Reset, d.h. das Programm startet neu.
bg.LightSleep32=light sleep 32 
bg.LightSleep32.description=Schlafe für <ms> Millisekunden. GPIO Ausgänge bleiben aktiviert, Uhr läuft weiter. Nach Ablauf der <ms> läuft das Programm wie gewohnt weiter 
bg.Frequency32=Frequency 32
bg.Frequency32.description=Ändert die CPU-Frequenz <f> in in MHz. Typische Werte 80, 160 oder 240 MHz. Kleinst möglicher Wert 10 MHz (energiesparend) 
bg.RTC_GPIO32=RTC_GPIO 32
bg.RTC_GPIO32.description=Normale GPIOs verlieren im Tiefschlaf ihren elekrischen Pegel. RTC-GPIOs können den Pegel auf den im <level> angegebenen Pegel stabilisieren. Beim ESP32 WROOM ist die für folgende GPIOs möglich: GPIO 0, GPIO 2, 4, 12-15, 25-27, 32-36, 39.
bg.modemSleep=modem sleep
bg.modemSleep.description=Schaltet das WiFi-Modem aus (energy saving) 
bg.readReset=ResetInfo 8266 
bg.readReset.description=Gibt den Grund für einen Neustart aus. Blöckchen am Anfang des setup() verwenden.  
bg.readReset32=ResetInfo 32 
bg.readReset32.description=Gibt den Grund für einen Neustart aus. Bsp. Reason 5 bei Aufwachen nach deepsleep. Reason 1 bei PowerUp. Blöckchen am Anfang des setup() verwenden.  














bg.basicOTA=OTA (On the Air Update)
bg.basicOTA.description=Ermöglicht on the air update. Aufspielen neuer Software per WLAN. Dazu müssen sich Client und Server im gleichen WLAN-Netz befinden. Das Blöckchen muss zyklisch aufgerufen werden (z.B. in einer Schleife) 

bd.control=Kontrollstrukturen 
bd.logic=Log. Operatoren 
bd.operators=Math. Operatoren 
bd.number=Variablen / Konstanten 
bd.ser_communication=Print / Adapter 
bd.input=Sensoren 
bd.signal=Signalverarbeitung
bd.input_ext=Externe Interfaces 
bd.output=Anzeigen / Aktoren  
bd.WLAN_communication=IoT: WiFi 
bd.HTTP_communication=IoT: HTTP
bd.MQTT_communication=IoT: MQTT 
bd.LORA_communication=IoT: LoRaWAN 
bd.Blynk_communication=IoT: Blynk
bd.ESPNow=IoT: ESP-NOW
bd.database=IoT: EDGE KI  
bd.WLAN_NTP = IoT: NTP-Uhrzeit
bd.WLAN_privacy=IoT: Privatsphäre 

bd.MINT=IoT: MINT
bd.MED=IoT: COVID-19
